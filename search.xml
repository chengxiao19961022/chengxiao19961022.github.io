<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[静态数据流分析入门]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[编译器的一个重要功能是分析和优化代码。编译时分析（或称静态分析）得到若干信息后，编译器可以确定在何处应用何种变换是安全并且有利可图的。而其中一种重要的分析技术就是数据流分析。顾名思义，数据流分析就是分析数据如何在程序执行路径上流动的技术。 参考文章： 静态分析之数据流分析 SSA入门 定义编译器的一个重要功能是分析和优化代码。编译时分析（或称静态分析）得到若干信息后，编译器可以确定在何处应用何种变换是安全并且有利可图的。而其中一种重要的分析技术就是数据流分析。顾名思义，数据流分析就是分析数据如何在程序执行路径上流动的技术，那么数据流分析的前提条件就是基于 IR （源代码经过编译得到的中间表示形式）构造 CFG 控制流图。 一般应用场景基于数据流分析，可以实现多种全局优化： 复制传播：形如 u=v 的赋值之后，变量 u 用 v 代替 常量折叠：若每次运行时表达式的值是常量，则用此常量代替 全局公共子表达式：例如表达式 a+b 多处出现而且值都相同，那么可以只计算一次 死代码消除：删除其计算结果不被使用的语句等等。 数据流分析通用方法数据流问题研究的是程序的某个点处的数据流值。 数据流分析的通用方法是在控制流图上定义一组方程并迭代求解，一般分为正向传播和逆向传播。正向传播就是沿着控制流路径，状态向前传递，前驱块的值传到后继块；逆向传播就是逆着控制流路径，后继块的值反向传给前驱块。 传递函数与控制流约束。传递函数是指基本块的入口与出口的数据流值为两个集合，满足函数关系f，正向传播时入口值集 X，则出口值集为f(X)，逆向传播时出口值集X，则入口值集为f(X)。控制流约束是在一条路径两端的前驱与后继块的数据流值的传递关系。 到达定制与活跃变量分析到达定值考虑这样的一个问题，变量 x 在哪些地方被定值，在某个位置使用的 x 是这个值吗？ 某个地方变量 x 被赋值了，如果存在路径到达一个点，这个位置 x 被使用了，那么我们说定值 x 到达了此程序点。如果这条路径上 x 被重新定值，我们说 x 被杀死 (kill) 了。可以知道如果某个变量 x 的一个定值 d 到达点 p，那么 p 处使用的 x 的值就可能是 d 定义的。在流图的入口为 x 引入一个未定义值 ⊥，如果 ⊥ 能达到某个 x 的使用，那么说明这个地方的使用可能是未定义值，这就是一个程序错误隐患。 假设有一个程序的控制流图如下所示： 到达定值问题的传递函数被定义为：Out[s] = In[s] + gen - kill。gen 集合是块内的赋值语句产生的新定值，kill 集合是块内赋值语句 kill 的其他定值。对每个变量，有赋值语句则加入到 gen，其他位置的赋值语句都加入 kill。所有块的 gen/kill 集可以一趟扫描完成。路径上的约束为：In[B] = ∪ Out[P]，其中P是B的所有前驱块。另外还有边界条件：Out[Entry] = Φ。 建立完方程组之后，循环迭代，每轮迭代中，每个块的 In/Out 集合都在更新。直到所有的 In[s] 与 Out[s] 都不发生变化，此时就是最终的结果。这个结果是保守的，但不是精确的。因为路径是一个不可判定问题，我们只能尽可能保守的包含全部可能路径。因此，某些实际运行中不会走到的路径，也被我们允许穿越定值。伪代码如下： 1234567891011Init: Out[Entry] = Φ for each block: Out[B] = Φloops: In[B] = ∪ Out[P] Out[B] = In[B] + gen - kill 用表格表示计算结果如下： loop1 loop2 loop3 gen kill In Out In Out In Out Entry Φ Φ Φ Φ Φ Φ Φ Φ B1 1,2,3 4,5,6,7 Φ 1,2,3 Φ 1,2,3 Φ 1,2,3 B2 4,5 1,2,7 Φ 4,5 1,2,3,7 3,4,5 1,2,3,5,6,7 3,4,5,6 B3 6 3 Φ 6 3,4,5 4,5,6 3,4,5,6 4,5,6 B4 7 1,4 Φ 7 3,4,5,6 3,5,6,7 3,4,5,6 3,5,6,7 Exit Φ Φ Φ Φ 3,5,6,7 3,5,6,7 3,5,6,7 3,5,6,7 算法在第三轮停止。 以 exit 块为例，最终可到达的定值是d3, d5, d6, d7。也就是说图1中 d3, d5, d6, d7 这几行赋值语句的定值，能传递到结束位置。 活跃变量分析在这个例子中，我们希望知道变量 x 在某个位置 p 处的值，是否在流图上某条从 p 出发的路径上所使用。如果答案是真，那么我们说 x 在 p 上活跃 (live)，如果答案是假，我们说 x 在 p 上是死 (dead) 的。 这里我们用In[B] Out[B] 分别表示基本块的入口与出口处的活跃变量。这里定义 def 集合为变量在块中被定值之前未被使用，use 集合为变量在块中被使用前未被定值。很容易想到，在块中先被使用的变量在入口是活跃的，在块中先被定义的变量被杀死了，而块中不相关的变量则在块入口的状态与块出口的状态一致。则有传递函数为 In[B] = use + (Out[B] - def)。控制流约束为 Out[B] = ∪ In[S],（其中 S 为 B 的全部后继），等同于变量离开块时活跃当且仅当在某个后继块的入口处活跃。边界条件为 In[Exit] = Φ。 同样方程组迭代求解。伪码如下： 123456789101112Init: In[Exit] = Φ for each block: In[B] = Φloops: Out[B] = ∪ In[S] In[B] = Out[B] + use - def 可以看到这组方程的一个特点是逆向传播。从 Exit 开始，每个块出口传播到入口，后继块传播到前驱块。与上面的问题刚好相反。但是迭代求解的方法是相同的。 数据流问题的通用框架数据流分析研究的具体问题不同，但方法非常相似，就是在控制流图上定义一组方程组然后迭代求解。方程组有以下特点： 数据流值在每个结点 s 的前后分别记为 In[s] 与 Out[s] In[s] 与 Out[s] 之间有约束关系即传递函数，含义是单个块对数据流值的改变 控制流路径前后结点 s, s’ 的 In[s’] 与 Out[s] 有约束关系，含义是数据在路径上的流动 所有结点的 In[s] 与 Out[s] 及其相互约束关系构成方程组 迭代遍历控制流图，在每个结点处对方程反复求值，直到方程组的解到达定值即不动点 方程定义在数据流值上。数据流值传播的路径一般分正向和逆向。控制路径上的约束，通常是交集或并集，例如 In[s] = ∪ Out[s’] (例如定值问题和活跃变量问题) 或 In[s] = ∩ Out[s’] (例如可用表达式问题) 。块内的传递函数，通常写为 Out[s] = In[s] + GenSet - KillSet 的形式。 数据流问题都可以用这样的框架来解决，它们之间的区别无非是定义域不同，传递函数不同，控制流约束不同，或者数据流方向不同。 数据流分析算法分析一个算法必须回答几个问题：算法收敛性，算法是可停机的吗？算法正确性，结果是正确的吗？算法的复杂度可接受吗？ 数据流分析的算法框架可以抽象为一个代数问题。数据流值全部可能的取值的幂集为V，在 V 上定义一个半格 (semilattice)，有meet 运算 ∧。两个元素的 ∧ 运算得到它们的最大下界。半格的 meet 运算 ∧ 有以下特点：等幂：x ∧ x = x; 可交换 x ∧ y = y ∧ x; 有结合律x (y ∧ z) = (x ∧ y) ∧ z. ∧ 运算定义了半格上的偏序关系 ≤。半格的顶元素 T 满足：任意 x ∈ V, x ∧ T = x，底元素 ⊥ 满足：任意 x ∈ V, x ∧ ⊥ = ⊥。底即最小元素，顶即最大元素。 ∧ 运算实际就是控制流约束。在控制流算法框架里面，就是并集或者交集运算，偏序关系实际就是包含或被包含关系。以定值问题举例，如图2所示，所有可能的定值构成半格，顶为空集，底为满集。箭头的指向表明了偏序关系 ≤。控制流上的 meet 运算 ∧ 是并集运算∪, 偏序关系 ≤ 是 包含关系 ⊇。 框架中的传递函数族F: V → V，包含了块内的传递函数f，以及传递函数的组合。传递函数的组合封闭于函数族F。f ∈ F 是单调函数。x ≤ y 等价于 f(x) ≤ f(y). 基于以上模型，以正向传播为例，控制流算法框架的模型可以写作如下形式： 12345678910Init: for each block: Out[B] = TLoop: In[B] = ∧ Out[P] Out[B] = fb(In[B]) 我们来看迭代过程。每次迭代，对每个程序点 p 上的值，In[B] = ∧ Out[P] 导致值在格上位置下降，fb(In[B]) 是单调函数也会导致值在格上下降。格的高度是有限的，基本块的数量也是有限的，所以迭代算法必然能够收敛。迭代得到的结果就是在格上组合传递函数的最大不动点。 从 Entry 到基本块 B 上的路径 p，所有经过的块的传递函数组合为 fp = f1▫f2▫f3…= f1(f2(f3…))), 最理想的解 IDEAL[B] = ∧ fp(Entry)，其中 p 为所有可能路径。IDEAL[B] 满足数据流方程组，而且根据单调函数 f ∈ F 的等价关系 f(x ∧ y) ≤ f(x) ∧ f(y) 知道，IDEAL[B] 是最大的正确答案，即精确解。迭代解是正确的，但是可能小于理想解，即不够精确。 因为迭代算法是格下降的，格的最大高度为值集中元素数量 - 1，以块为单位时，最大高度是块的数量 - 1。同时每次迭代需要遍历全部基本块，所以最恶劣情况下，时间复杂度为 O(n ^ 2)，n 为基本块数量。 以上是对数据流迭代分析算法的简单总结。例子与图引用自《编译原理》。！]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>数据流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Monkey Test]]></title>
    <url>%2F2019%2F01%2F21%2FAndroid-Monkey-Test%2F</url>
    <content type="text"><![CDATA[Monkey测试是Android平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动Trackball、按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常。 特点Monkey测试的特点主要有以下几点： 可对MonkeyTest的对象，事件数量，类型，频率等进行设置。 Monky测试使用的事件流数据流是随机的，不能进行自定义。 测试的对象仅为应用程序包，有一定的局限性。 Monkey命令常规命令 -help 作用：列出简单的用法例：adb shell monkey -help -v 作用：命令行上的每一个-v都将增加反馈信息的详细级别。 Level0（默认），除了启动、测试完成和最终结果外只提供较少的信息。 Level1，提供了较为详细的测试信息，如逐个发送到Activity的事件信息。 Level2，提供了更多的设置信息，如测试中选中或未选中的Activity信息。 例： 123adb shell monkey -v 10adb shell monkey -v -v 10adb shell monkey -v -v -v 10 事件-s &lt;seed&gt; 作用：伪随机数生成器的seed值。如果用相同的seed值再次运行monkey，将生成相同的事件序列。例：adb shell monkey -s 12345 -v 10 --throttle &lt;milliseconds&gt; 作用：在事件之间插入固定的时间（毫秒）延迟，你可以使用这个设置来减缓Monkey的运行速度，如果你不指定这个参数，则事件之间将没有延迟，事件将以最快的速度生成。例: adb shell monkey –throttle 300 -v 10 注：常用参数，一般设置为300毫秒，原因是实际用户操作的最快300毫秒左右一个动作事件，所以此处一般设置为300毫秒。 --pct-touch &lt;percent&gt; 作用：调整触摸事件的百分比。（触摸事件是指在屏幕中的一个down-up事件，即在屏幕某处按下并抬起的操作）例：adb shell monkey –pct-touch 100 -v 10 注：常用参数，此参数设置要适应当前被测应用程序的操作，比如一个应用80%的操作都是触摸，那就可以将此参数的百分比设置成相应较高的百分比。 --pct-motion &lt;percent&gt; 作用：调整motion事件百分比。（motion事件是由屏幕上某处一个down事件、一系列伪随机的移动事件和一个up事件组成）例：adb shell monkey –pct-motion 100 -v 10 注：常用参数，需注意的是移动事件是直线滑动，下面的trackball移动包含曲线移动。 --pct-trackball &lt;percent&gt; 作用：调整滚动球事件百分比。（滚动球事件由一个或多个随机的移动事件组成，有时会伴随着点击事件）例：adb shell monkey –pct-trackball 100 -v 10 注：不常使用参数，现在手机几乎没有滚动球，但滚动球事件中包含曲线滑动事件，在被测程序需要曲线滑动时可以选用此参数。 --pct-nav &lt;percent&gt; 作用：调整基本的导航事件百分比。（导航事件由方向输入设备的上下左右按键所触发的事件组成）例：adb shell monkey –pct-nav 100 -v 10注：不常用操作。 --pct-majornav &lt;percent&gt; 作用：调整主要导航事件的百分比。（这些导航事件通常会导致UI界面中的动作事件，如5-way键盘的中间键，回退按键、菜单按键）例：adb shell monkey –pct-majornav 100 -v 10 --pct-syskeys &lt;percent&gt; 作用：调整系统事件百分比。（这些按键通常由系统保留使用，如Home、Back、Start Call、End Call、音量调节）例：adb shell monkey –pct-syskeys 100 -v 10 --pct-appswitch &lt;percent&gt; 作用：调整Activity启动的百分比。（在随机的时间间隔中，Monkey将执行一个startActivity()调用，作为最大程度覆盖被测包中全部Activity的一种方法）例：adb shell monkey –pct-appswitch 100 -v 5 --pct-anyevent作用：调整其他事件的百分比。（这包含所有其他事件，如按键、其他在设备上不常用的按钮等）例：adb shell monkey –pct-anyevent 100 -v 5 约束条件-p &lt;allowed-package-name&gt; 作用：如果你指定一个或多个包，Monkey将只允许访问这些包中的Activity。如果你的应用程序需要访问这些包(如选择联系人)以外的Activity，你需要指定这些包。如果你不指定任何包，Monkey将允许系统启动所有包的Activity。指定多个包，使用多个-p，一个-p后面接一个包名。例：adb shell monkey -p com.android.browser -v 10 -c &lt;main-category&gt; 作用：如果你指定一个或多个类别，Monkey将只允许系统启动这些指定类别中列出的Activity。如果你不指定任何类别，Monkey将选择谢列类别中列出的Activity，Intent.CATEGORY_LAUNCHER和Intent.CATEGORY_MONKEY。指定多个类别使用多个-c，每个-c指定一个类别。例：adb shell monkey -p com.paipai.ershou -v 10 -c --dbg-no-events作用：设置此选项，Monkey将执行初始启动，进入一个测试Activity，并不会在进一步生成事件。为了得到最佳结果，结合参数-v，一个或多个包的约束，以及一个保持Monkey运行30秒或更长时间的非零值，从而提供了一个可以监视应用程序所调用的包之间转换的环境。 --hprof作用：设置此选项，将在Monkey生成事件序列前后生成profilling报告。在data/misc路径下生成大文件（~5Mb），所以要小心使用。 --ignore-crashes作用：通常，应用发生崩溃或异常时Monkey会停止运行。如果设置此项，Monkey将继续发送事件给系统，直到事件计数完成。 --ignore-security-exception作用：通常，当程序发生许可错误（例如启动一些需要许可的Activity）导致的异常时，Monkey将停止运行。设置此项，Monkey将继续发送事件给系统，直到事件计数完成。 --kill-process-after-error作用：通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。设置此项，将会通知系统停止发生错误的进程。注意，正常（成功）的结束，并没有停止启动的进程，设备只是在结束事件之后简单的保持在最后的状态。 --monitor-native-crashes作用：监视并报告Andorid系统中本地代码的崩溃事件。如果设置–kill-process-after-error，系统将停止运行。 --wait-dbg作用：停止执行中的Monkey，直到有调试器和它相连接。 记录测试日志保存测试日志其实很简单，命令如下： 1adb shell monkey -p com.ihongqiqu -v -v -v 500 &gt; monkeytest.txt 参考 https://developer.android.com/tools/help/monkey.html https://developer.android.com/tools/testing/testing_android.html#Monkeys]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法]]></title>
    <url>%2F2018%2F09%2F05%2F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一些经典算法 排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316//// Created by 76947 on 2018/3/6.//#include &lt;vector&gt;#include "Sort.h"void swap1(int *left, int *right)&#123; int temp = *left; *left = *right; *right = temp;&#125;void swap2(int &amp;left, int &amp;right)&#123; int temp = left; left = right; right = temp;&#125;void swap3(int &amp;left, int &amp;right)&#123; if (&amp;left != &amp;right) &#123; left ^= right; right ^= left; left ^= right; &#125;&#125;// 直接插入排序void InsertSort(int a[], int n)&#123; for (int i = 1; i &lt; n; ++i)&#123; if(a[i] &lt; a[i-1])&#123; int j = i - 1; int key = a[i];// for (; j&gt;=0 ; --j) &#123;//// if( a[j] &lt;= key) break;// a[j+1] = a[j];// &#125; a[i] = a[i-1]; while (a[j] &gt; key) &#123; a[j + 1] = a[j]; --j; &#125; a[j + 1] = key; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125;&#125;// 希尔排序void ShellInsertSort(int n,int a[], int dl)&#123; for (int i = dl; i &lt; n; ++i) &#123; if (a[i] &lt; a[i-dl])&#123; int j = i-dl; int key = a[i]; a[i] = a[i-dl]; while(a[j] &gt; key)&#123; a[j+dl] = a[j]; j -= dl; &#125; a[j+dl] = key; &#125; &#125;// for (int k = 0; k &lt; n; ++k) &#123;// cout&lt;&lt;a[k]&lt;&lt;" ";// &#125;&#125;void ShellSort(int a[], int n)&#123; int dl = n/2; while (dl &gt;= 1)&#123; ShellInsertSort(n,a,dl); dl = dl/2; &#125; for(int i = 0; i &lt; n; ++i)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125;&#125;/****************************************************************************//*希尔排序:先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2) */void ShellSort2(int *arr, int N)&#123; int i, j, increment; int tmp; for (increment = N / 2; increment &gt; 0; increment /= 2) &#123; for (i = increment; i &lt; N; i++) &#123; tmp = arr[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if (arr[j - increment] &gt; tmp) arr[j] = arr[j - increment]; else break; &#125; arr[j] = tmp; &#125; &#125;&#125;// 桶排序void TongSort(int a[], int n)&#123; // 寻找a[]中最大的元素 int max = a[0]; for (int j = 1; j &lt; n; ++j) &#123; if (max&lt;a[j]) max = a[j]; &#125; int b[max+1] = &#123;0&#125;; for (int i = 0; i &lt; n; ++i) &#123; ++b[a[i]]; &#125; for (int k = 0; k &lt;= max; ++k) &#123; for (int i = 0; i &lt; b[k]; ++i) &#123; cout&lt;&lt; k &lt;&lt; " "; &#125; &#125;&#125;// 冒泡排序void BubbleSort(int a[], int n)&#123; for (int i = 0; i &lt; n-1; ++i) &#123; for (int j = 0; j &lt; n-i-1; ++j) &#123; if (a[j+1] &lt; a[j])&#123; a[j] = a[j]^a[j+1]; a[j+1] = a[j]^a[j+1]; a[j] = a[j]^a[j+1]; &#125; &#125; &#125; for (int k = 0; k &lt; n; ++k) &#123; cout &lt;&lt; a[k] &lt;&lt; " "; &#125;&#125;// 快速排序void quickSort(int a[], int left, int right)&#123; if (left &gt;= right) return; int key = a[left]; int i = left, j = right; while(i &lt; j)&#123; while ((i &lt; j)&amp;&amp;(a[j] &gt;= key))--j; while ((i &lt; j)&amp;&amp;(a[i] &lt;= key))++i; if (i &lt; j) &#123; int k = a[i]; a[i] = a[j]; a[j] = k; &#125; &#125; int k = a[i]; a[i] = a[left]; a[left] = k; quickSort(a, left, i-1); quickSort(a, i+1, right);&#125;/************************************************************************************//* 堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆；* 或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆*//*堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶* 的根结点.将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新* 构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了*//* 时间复杂度为 O(nlogn),好于冒泡,简单选择,直接插入的O(n^2) */#define leftChild(i) (2*(i) + 1)void percDown(int *arr, int i, int N)&#123; int tmp = arr[i]; int child; // 为了找到arr[i]的位置 while(leftChild(i) &lt; N)&#123; child = leftChild(i); if (child != N - 1 &amp;&amp; arr[child+1] &gt; arr[child])&#123; ++child; &#125; if (arr[child] &gt; tmp)&#123; arr[i] = arr[child]; &#125; else&#123; break; &#125; i = child; &#125; arr[i] = tmp;&#125;void HeapSort(int *arr, int N)&#123; for (int i = N/2; i &gt;= 0; --i) &#123; percDown(arr, i, N); &#125; // 每次把最大值放在树尾，并整理剩下的堆 for (int j = N-1; j &gt;= 0 ; --j) &#123; swap2(arr[0], arr[j]); percDown(arr, 0, j); &#125;&#125;/**************************************************************************//* 简单选择排序(simple selection sort) 就是通过n-i次关键字之间的比较,从n-i+1* 个记录中选择关键字最小的记录,并和第i(1&lt;=i&lt;=n)个记录交换之* 尽管与冒泡排序同为O(n^2),但简单选择排序的性能要略优于冒泡排序 */void SelectSort(int arr[], int num)&#123; int i, j, Mindex; for (i = 0; i &lt; num; i++) &#123; Mindex = i; for (j = i + 1; j &lt; num; j++) &#123; if (arr[j] &lt; arr[Mindex]) Mindex = j; &#125; swap1(&amp;arr[i], &amp;arr[Mindex]); &#125;&#125;// 归并排序//https://blog.csdn.net/morewindows/article/details/6678165//将有二个有序数列a[first...mid]和a[mid+1...last]合并。void mergearray(int a[], int first, int mid, int last)&#123; int i = first, j = mid + 1; int m = mid, n = last; vector&lt;int&gt; temp; while (i &lt;= m &amp;&amp; j &lt;= n) &#123; if (a[i] &lt;= a[j]) temp.push_back(a[i++]); else temp.push_back(a[j++]); &#125; while (i &lt;= m) temp.push_back(a[i++]); while (j &lt;= n) temp.push_back(a[j++]); for (i = 0; i &lt; temp.size(); i++) a[first + i] = temp[i];&#125;void mergesort(int a[], int first, int last)&#123; if (first &lt; last) &#123; int mid = (first + last) / 2; mergesort(a, first, mid); //左边有序 mergesort(a, mid + 1, last); //右边有序 mergearray(a, first, mid, last); //再将二个有序数列合并 &#125;&#125;bool MergeSort(int a[], int n)&#123;// int *p = new int[n];// if (p == NULL)// return false; mergesort(a, 0, n - 1);// delete[] p; return true;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antlr4使用教程]]></title>
    <url>%2F2018%2F09%2F04%2FAntlr4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Antlr是一款强大的语法分析器生成工具，可用于读取、处理、执行和翻译结构化的文本或二进制文件。它被广泛用于学术领域和工业生产领域，是众多语言、工具和框架的基石。 安装及配置(unix)安装可直接下载jar包或用命令行安装 123$ cd /usr/local/lib$ curl -O http://www.antlr.org/download/antlr-4.7.1-complete.jar 配置1234567#!~/.bash_profile$ export CLASSPATH=".:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH"$ alias antlr4='java -jar /usr/local/lib/antlr-4.7.1-complete.jar'$ alias grun='java org.antlr.v4.gui.TestRig' 验证123$ antlr4$ grun 一些概念词法和语法 语言：一门语言是一个有效语句的集合。语句由词组组成，子词组又有更小的子词组组成，依次类推。 语法：语法定义了语言的语义规则。语法中的每条规则定义了一种词组结构。 语义树或语法分析树：代表了语句的结构，其中的每个子树的根节点都使用一个抽象的名字给其包含的元素命名。即字子树的根节点对应了语法规则的名字。树的叶子节点是语句中的符号或词法符号。 词法符号：是一门语言的基本词汇符号，它们可以代表像是“标识符”这样的一类符号，也可以代表一个单一的运算符，或者代表一个关键字。 词法分析器或者词法符号生成器：将输入的字符序列分解成一系列词法符号。一个此法分析器负责分析词法。 语法分析器：语法分析器通过检查语句的结构是否符合语法规则的定义来验证该语句在特定语言中是否合法。语法分析的过程好比是走迷宫，通过比较语句中的地板上的单词来从入口到出口。ANTLR能够生成被称为ALL()的自顶向下的语法分析器。ALL()是指它可以利用剩余的所有输入文本来进行决策。自顶向下的语法分析器以结果为导向，首先匹配最粗粒度的规则。 词法符号比如INT、STRING、ID等基本的token，词法分析（lexical analysis）又叫词法符号化（tokenizing）。 在语法分析的过程会建立语法分析树或叫句法树，语法分析树的内部节点是词组名，子根节点表达的是语法文件中的规则(rule)，也叫做rulenode，也叫做context对象，叶子节点永远是输入的词法符号，也叫做terminalnode。 语法分析树监听器和访问器项目实战chap3ArrayInit12345678910111213141516/** Grammars always start with a grammar header. This grammar is called * ArrayInit and must match the filename: ArrayInit.g4 */grammar ArrayInit;/** A rule called init that matches comma-separated values between &#123;...&#125;. */init : &apos;&#123;&apos; value (&apos;,&apos; value)* &apos;&#125;&apos; ; // must match at least one value/** A value can be either a nested array/struct or a simple integer (INT) */value : init | INT ;// parser rules start with lowercase letters, lexer rules with uppercaseINT : [0-9]+ ; // Define token INT as one or more digitsWS : [ \t\r\n]+ -&gt; skip ; // Define whitespace rule, toss it out 123456789101112131415161718192021222324$ antlr4 ArrayInit.g4 # Generate parser and lexer using antlr4 alias$ javac ArrayInit*.java # Compile ANTLR-generated code➾ $ grun ArrayInit init -tokens➾ &#123;99, 3, 451&#125;➾EOF❮ [@0,0:0='&#123;',&lt;1&gt;,1:0][@1,1:2='99',&lt;4&gt;,1:1][@2,3:3=',',&lt;2&gt;,1:3][@3,5:5='3',&lt;4&gt;,1:5][@4,6:6=',',&lt;2&gt;,1:6][@5,8:10='451',&lt;4&gt;,1:8][@6,11:11='&#125;',&lt;3&gt;,1:11][@7,13:12='&lt;EOF&gt;',&lt;-1&gt;,2:0]➾ $ grun ArrayInit init -tree➾ &#123;99, 3, 451&#125;➾EOF❮ (init &#123; (value 99) , (value 3) , (value 451) &#125;)➾ $ grun ArrayInit init -gui➾ &#123;1,&#123;2,3&#125;,4&#125;➾EOF chap4Expr123456789101112131415161718192021grammar Expr;/** The start rule; begin parsing here. */prog: stat+ ;stat: expr NEWLINE | ID &apos;=&apos; expr NEWLINE | NEWLINE ;expr: INT | ID | &apos;(&apos; expr &apos;)&apos; | expr (&apos;*&apos;|&apos;/&apos;) expr | expr (&apos;+&apos;|&apos;-&apos;) expr ;ID : [a-zA-Z]+ ; // match identifiers &lt;label id=&quot;code.tour.expr.3&quot;/&gt;INT : [0-9]+ ; // match integersNEWLINE:&apos;\r&apos;? &apos;\n&apos; ; // return newlines to parser (is end-statement signal)WS : [ \t]+ -&gt; skip ; // toss out whitespace 123456789101112131415161718192021222324252627//: ExprJoyRide.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.FileInputStream;import java.io.InputStream;public class ExprJoyRide &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); ExprLexer lexer = new ExprLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); ExprParser parser = new ExprParser(tokens); ParseTree tree = parser.prog(); // parse; start at prog &lt;label id="code.tour.main.6"/&gt; System.out.println(tree.toStringTree(parser)); // print tree as text &lt;label id="code.tour.main.7"/&gt; &#125;&#125; 12345193a = 5b = 6a+b*2(1+2)*3 1234567891011121314$ antlr4 Expr.g4$ javac Expr*.java ExprJoyRide.java$ grun Expr prog -gui t.expr # launches org.antlr.v4.runtime.misc.TestRig$ java ExprJoyRide test❮ (prog(stat (expr 193) \n)(stat a = (expr 5) \n)(stat b = (expr 6) \n)(stat (expr (expr a) + (expr (expr b) * (expr 2))) \n)(stat (expr (expr ( (expr (expr 1) + (expr 2)) )) * (expr 3)) \n)) LibExpr12345678910111213141516171819202122232425// CommonLexerRules.g4lexer grammar CommonLexerRules; // note &quot;lexer grammar&quot;ID : [a-zA-Z]+ ; // match identifiersINT : [0-9]+ ; // match integersNEWLINE:&apos;\r&apos;? &apos;\n&apos; ; // return newlines to parser (end-statement signal)WS : [ \t]+ -&gt; skip ; // toss out whitespace// LibExpr.g4grammar LibExpr; // Rename to distinguish from originalimport CommonLexerRules; // includes all rules from CommonLexerRules.g4/** The start rule; begin parsing here. */prog: stat+ ;stat: expr NEWLINE | ID &apos;=&apos; expr NEWLINE | NEWLINE ;expr: expr (&apos;*&apos;|&apos;/&apos;) expr | expr (&apos;+&apos;|&apos;-&apos;) expr | INT | ID | &apos;(&apos; expr &apos;)&apos; ; 123456789101112131415161718192021222324252627//: ExprJoyRide.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.FileInputStream;import java.io.InputStream;public class ExprJoyRide &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); LibExprLexer lexer = new LibExprLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); LibExprParser parser = new LibExprParser(tokens); ParseTree tree = parser.prog(); // parse; start at prog &lt;label id="code.tour.main.6"/&gt; System.out.println(tree.toStringTree(parser)); // print tree as text &lt;label id="code.tour.main.7"/&gt; &#125;&#125; LabeledExpr123456789101112131415161718192021222324grammar LabeledExpr; // rename to distinguish from Expr.g4prog: stat+ ;stat: expr NEWLINE # printExpr | ID &apos;=&apos; expr NEWLINE # assign | NEWLINE # blank ;expr: expr op=(&apos;*&apos;|&apos;/&apos;) expr # MulDiv | expr op=(&apos;+&apos;|&apos;-&apos;) expr # AddSub | INT # int | ID # id | &apos;(&apos; expr &apos;)&apos; # parens ;MUL : &apos;*&apos; ; // assigns token name to &apos;*&apos; used above in grammarDIV : &apos;/&apos; ;ADD : &apos;+&apos; ;SUB : &apos;-&apos; ;ID : [a-zA-Z]+ ; // match identifiersINT : [0-9]+ ; // match integersNEWLINE:&apos;\r&apos;? &apos;\n&apos; ; // return newlines to parser (is end-statement signal)WS : [ \t]+ -&gt; skip ; // toss out whitespace 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//: EvalVisitor.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import java.util.HashMap;import java.util.Map;public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123; /** "memory" for our calculator; variable/value pairs go here */ Map&lt;String, Integer&gt; memory = new HashMap&lt;String, Integer&gt;(); /** ID '=' expr NEWLINE */ @Override public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123; String id = ctx.ID().getText(); // id is left-hand side of '=' int value = visit(ctx.expr()); // compute value of expression on right memory.put(id, value); // store it in our memory return value; &#125; /** expr NEWLINE */ @Override public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123; Integer value = visit(ctx.expr()); // evaluate the expr child System.out.println(value); // print the result return 0; // return dummy value &#125; /** INT */ @Override public Integer visitInt(LabeledExprParser.IntContext ctx) &#123; return Integer.valueOf(ctx.INT().getText()); &#125; /** ID */ @Override public Integer visitId(LabeledExprParser.IdContext ctx) &#123; String id = ctx.ID().getText(); if ( memory.containsKey(id) ) return memory.get(id); return 0; &#125; /** expr op=('*'|'/') expr */ @Override public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123; int left = visit(ctx.expr(0)); // get value of left subexpression int right = visit(ctx.expr(1)); // get value of right subexpression if ( ctx.op.getType() == LabeledExprParser.MUL ) return left * right; return left / right; // must be DIV &#125; /** expr op=('+'|'-') expr */ @Override public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123; int left = visit(ctx.expr(0)); // get value of left subexpression int right = visit(ctx.expr(1)); // get value of right subexpression if ( ctx.op.getType() == LabeledExprParser.ADD ) return left + right; return left - right; // must be SUB &#125; /** '(' expr ')' */ @Override public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123; return visit(ctx.expr()); // return child expr's value &#125;&#125; 12345678910111213141516171819202122232425262728293031//: Calc.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.ParseTree;import java.io.FileInputStream;import java.io.InputStream;public class Calc &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); LabeledExprLexer lexer = new LabeledExprLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); LabeledExprParser parser = new LabeledExprParser(tokens); ParseTree tree = parser.prog(); // parse EvalVisitor eval = new EvalVisitor(); eval.visit(tree); &#125;&#125; 12345193a = 5b = 6a+b*2(1+2)*3 123456$ java Calc test19356179 ExtractJava123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729// Java.g4/** Java 1.6 grammar (ANTLR v4). Derived from http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf and JavaParser.g from ANTLR v3 */grammar Java;@lexer::members &#123; protected boolean enumIsKeyword = true; protected boolean assertIsKeyword = true;&#125;// starting point for parsing a java filecompilationUnit : packageDeclaration? importDeclaration* typeDeclaration* EOF ;packageDeclaration : &apos;package&apos; qualifiedName &apos;;&apos; ;importDeclaration : &apos;import&apos; &apos;static&apos;? qualifiedName (&apos;.&apos; &apos;*&apos;)? &apos;;&apos; ;typeDeclaration : classOrInterfaceModifier* ( classDeclaration | interfaceDeclaration | enumDeclaration ) | &apos;;&apos; ;classDeclaration : &apos;class&apos; Identifier typeParameters? (&apos;extends&apos; type)? (&apos;implements&apos; typeList)? classBody ;enumDeclaration : ENUM Identifier (&apos;implements&apos; typeList)? enumBody ;interfaceDeclaration : normalInterfaceDeclaration | annotationTypeDeclaration ;classOrInterfaceModifier : annotation // class or interface | &apos;public&apos; // class or interface | &apos;protected&apos; // class or interface | &apos;private&apos; // class or interface | &apos;abstract&apos; // class or interface | &apos;static&apos; // class or interface | &apos;final&apos; // class only -- does not apply to interfaces | &apos;strictfp&apos; // class or interface ;modifiers : modifier* ;typeParameters : &apos;&lt;&apos; typeParameter (&apos;,&apos; typeParameter)* &apos;&gt;&apos; ;typeParameter : Identifier (&apos;extends&apos; typeBound)? ;typeBound : type (&apos;&amp;&apos; type)* ;enumBody : &apos;&#123;&apos; enumConstants? &apos;,&apos;? enumBodyDeclarations? &apos;&#125;&apos; ;enumConstants : enumConstant (&apos;,&apos; enumConstant)* ;enumConstant : annotations? Identifier arguments? classBody? ;enumBodyDeclarations : &apos;;&apos; (classBodyDeclaration)* ;normalInterfaceDeclaration : &apos;interface&apos; Identifier typeParameters? (&apos;extends&apos; typeList)? interfaceBody ;typeList : type (&apos;,&apos; type)* ;classBody : &apos;&#123;&apos; classBodyDeclaration* &apos;&#125;&apos; ;interfaceBody : &apos;&#123;&apos; interfaceBodyDeclaration* &apos;&#125;&apos; ;classBodyDeclaration : &apos;;&apos; | &apos;static&apos;? block | modifiers member ;member : genericMethodDeclaration | methodDeclaration | fieldDeclaration | constructorDeclaration | interfaceDeclaration | classDeclaration ;methodDeclaration : type Identifier formalParameters (&apos;[&apos; &apos;]&apos;)* methodDeclarationRest | &apos;void&apos; Identifier formalParameters methodDeclarationRest ;methodDeclarationRest : (&apos;throws&apos; qualifiedNameList)? ( methodBody | &apos;;&apos; ) ;genericMethodDeclaration : typeParameters methodDeclaration ;fieldDeclaration : type variableDeclarators &apos;;&apos; ;constructorDeclaration : typeParameters? Identifier formalParameters (&apos;throws&apos; qualifiedNameList)? constructorBody ;interfaceBodyDeclaration : modifiers interfaceMemberDecl | &apos;;&apos; ;interfaceMemberDecl : interfaceMethodOrFieldDecl | interfaceGenericMethodDecl | &apos;void&apos; Identifier voidInterfaceMethodDeclaratorRest | interfaceDeclaration | classDeclaration ;interfaceMethodOrFieldDecl : type Identifier interfaceMethodOrFieldRest ;interfaceMethodOrFieldRest : constantDeclaratorsRest &apos;;&apos; | interfaceMethodDeclaratorRest ;voidMethodDeclaratorRest : formalParameters (&apos;throws&apos; qualifiedNameList)? ( methodBody | &apos;;&apos; ) ;interfaceMethodDeclaratorRest : formalParameters (&apos;[&apos; &apos;]&apos;)* (&apos;throws&apos; qualifiedNameList)? &apos;;&apos; ;interfaceGenericMethodDecl : typeParameters (type | &apos;void&apos;) Identifier interfaceMethodDeclaratorRest ;voidInterfaceMethodDeclaratorRest : formalParameters (&apos;throws&apos; qualifiedNameList)? &apos;;&apos; ;constantDeclarator : Identifier constantDeclaratorRest ;variableDeclarators : variableDeclarator (&apos;,&apos; variableDeclarator)* ;variableDeclarator : variableDeclaratorId (&apos;=&apos; variableInitializer)? ;constantDeclaratorsRest : constantDeclaratorRest (&apos;,&apos; constantDeclarator)* ;constantDeclaratorRest : (&apos;[&apos; &apos;]&apos;)* &apos;=&apos; variableInitializer ;variableDeclaratorId : Identifier (&apos;[&apos; &apos;]&apos;)* ;variableInitializer : arrayInitializer | expression ;arrayInitializer : &apos;&#123;&apos; (variableInitializer (&apos;,&apos; variableInitializer)* (&apos;,&apos;)? )? &apos;&#125;&apos; ;modifier : annotation | &apos;public&apos; | &apos;protected&apos; | &apos;private&apos; | &apos;static&apos; | &apos;abstract&apos; | &apos;final&apos; | &apos;native&apos; | &apos;synchronized&apos; | &apos;transient&apos; | &apos;volatile&apos; | &apos;strictfp&apos; ;packageOrTypeName : qualifiedName ;enumConstantName : Identifier ;typeName : qualifiedName ;type: classOrInterfaceType (&apos;[&apos; &apos;]&apos;)* | primitiveType (&apos;[&apos; &apos;]&apos;)* ;classOrInterfaceType : Identifier typeArguments? (&apos;.&apos; Identifier typeArguments? )* ;primitiveType : &apos;boolean&apos; | &apos;char&apos; | &apos;byte&apos; | &apos;short&apos; | &apos;int&apos; | &apos;long&apos; | &apos;float&apos; | &apos;double&apos; ;variableModifier : &apos;final&apos; | annotation ;typeArguments : &apos;&lt;&apos; typeArgument (&apos;,&apos; typeArgument)* &apos;&gt;&apos; ;typeArgument : type | &apos;?&apos; ((&apos;extends&apos; | &apos;super&apos;) type)? ;qualifiedNameList : qualifiedName (&apos;,&apos; qualifiedName)* ;formalParameters : &apos;(&apos; formalParameterDecls? &apos;)&apos; ;formalParameterDecls : variableModifiers type formalParameterDeclsRest ;formalParameterDeclsRest : variableDeclaratorId (&apos;,&apos; formalParameterDecls)? | &apos;...&apos; variableDeclaratorId ;methodBody : block ;constructorBody : &apos;&#123;&apos; explicitConstructorInvocation? blockStatement* &apos;&#125;&apos; ;explicitConstructorInvocation : nonWildcardTypeArguments? (&apos;this&apos; | &apos;super&apos;) arguments &apos;;&apos; | primary &apos;.&apos; nonWildcardTypeArguments? &apos;super&apos; arguments &apos;;&apos; ;qualifiedName : Identifier (&apos;.&apos; Identifier)* ;literal : integerLiteral | FloatingPointLiteral | CharacterLiteral | StringLiteral | booleanLiteral | &apos;null&apos; ;integerLiteral : HexLiteral | OctalLiteral | DecimalLiteral ;booleanLiteral : &apos;true&apos; | &apos;false&apos; ;// ANNOTATIONSannotations : annotation+ ;annotation : &apos;@&apos; annotationName ( &apos;(&apos; ( elementValuePairs | elementValue )? &apos;)&apos; )? ;annotationName : Identifier (&apos;.&apos; Identifier)* ;elementValuePairs : elementValuePair (&apos;,&apos; elementValuePair)* ;elementValuePair : Identifier &apos;=&apos; elementValue ;elementValue : expression | annotation | elementValueArrayInitializer ;elementValueArrayInitializer : &apos;&#123;&apos; (elementValue (&apos;,&apos; elementValue)*)? (&apos;,&apos;)? &apos;&#125;&apos; ;annotationTypeDeclaration : &apos;@&apos; &apos;interface&apos; Identifier annotationTypeBody ;annotationTypeBody : &apos;&#123;&apos; (annotationTypeElementDeclaration)* &apos;&#125;&apos; ;annotationTypeElementDeclaration : modifiers annotationTypeElementRest ;annotationTypeElementRest : type annotationMethodOrConstantRest &apos;;&apos; | classDeclaration &apos;;&apos;? | normalInterfaceDeclaration &apos;;&apos;? | enumDeclaration &apos;;&apos;? | annotationTypeDeclaration &apos;;&apos;? ;annotationMethodOrConstantRest : annotationMethodRest | annotationConstantRest ;annotationMethodRest : Identifier &apos;(&apos; &apos;)&apos; defaultValue? ;annotationConstantRest : variableDeclarators ;defaultValue : &apos;default&apos; elementValue ;// STATEMENTS / BLOCKSblock : &apos;&#123;&apos; blockStatement* &apos;&#125;&apos; ;blockStatement : localVariableDeclarationStatement | classDeclaration | interfaceDeclaration | statement ;localVariableDeclarationStatement : localVariableDeclaration &apos;;&apos; ;localVariableDeclaration : variableModifiers type variableDeclarators ;variableModifiers : variableModifier* ;statement : block | ASSERT expression (&apos;:&apos; expression)? &apos;;&apos; | &apos;if&apos; parExpression statement (&apos;else&apos; statement)? | &apos;for&apos; &apos;(&apos; forControl &apos;)&apos; statement | &apos;while&apos; parExpression statement | &apos;do&apos; statement &apos;while&apos; parExpression &apos;;&apos; | &apos;try&apos; block ( catches &apos;finally&apos; block | catches | &apos;finally&apos; block ) | &apos;switch&apos; parExpression switchBlock | &apos;synchronized&apos; parExpression block | &apos;return&apos; expression? &apos;;&apos; | &apos;throw&apos; expression &apos;;&apos; | &apos;break&apos; Identifier? &apos;;&apos; | &apos;continue&apos; Identifier? &apos;;&apos; | &apos;;&apos; | statementExpression &apos;;&apos; | Identifier &apos;:&apos; statement ;catches : catchClause (catchClause)* ;catchClause : &apos;catch&apos; &apos;(&apos; formalParameter &apos;)&apos; block ;formalParameter : variableModifiers type variableDeclaratorId ;switchBlock : &apos;&#123;&apos; switchBlockStatementGroup* switchLabel* &apos;&#125;&apos; ;switchBlockStatementGroup : switchLabel+ blockStatement* ;switchLabel : &apos;case&apos; constantExpression &apos;:&apos; | &apos;case&apos; enumConstantName &apos;:&apos; | &apos;default&apos; &apos;:&apos; ;forControl : enhancedForControl | forInit? &apos;;&apos; expression? &apos;;&apos; forUpdate? ;forInit : localVariableDeclaration | expressionList ;enhancedForControl : variableModifiers type Identifier &apos;:&apos; expression ;forUpdate : expressionList ;// EXPRESSIONSparExpression : &apos;(&apos; expression &apos;)&apos; ;expressionList : expression (&apos;,&apos; expression)* ;statementExpression : expression ;constantExpression : expression ;expression : primary | expression &apos;.&apos; Identifier | expression &apos;.&apos; &apos;this&apos; | expression &apos;.&apos; &apos;super&apos; &apos;(&apos; expressionList? &apos;)&apos; | expression &apos;.&apos; &apos;new&apos; Identifier &apos;(&apos; expressionList? &apos;)&apos; | expression &apos;.&apos; &apos;super&apos; &apos;.&apos; Identifier arguments? | expression &apos;.&apos; explicitGenericInvocation | expression &apos;[&apos; expression &apos;]&apos; | expression &apos;(&apos; expressionList? &apos;)&apos; | expression (&apos;++&apos; | &apos;--&apos;) | (&apos;+&apos;|&apos;-&apos;|&apos;++&apos;|&apos;--&apos;) expression | (&apos;~&apos;|&apos;!&apos;) expression | &apos;(&apos; type &apos;)&apos; expression | &apos;new&apos; creator | expression (&apos;*&apos;|&apos;/&apos;|&apos;%&apos;) expression | expression (&apos;+&apos;|&apos;-&apos;) expression | expression (&apos;&lt;&apos; &apos;&lt;&apos; | &apos;&gt;&apos; &apos;&gt;&apos; &apos;&gt;&apos; | &apos;&gt;&apos; &apos;&gt;&apos;) expression | expression (&apos;&lt;&apos; &apos;=&apos; | &apos;&gt;&apos; &apos;=&apos; | &apos;&gt;&apos; | &apos;&lt;&apos;) expression | expression &apos;instanceof&apos; type | expression (&apos;==&apos; | &apos;!=&apos;) expression | expression &apos;&amp;&apos; expression | expression &apos;^&apos; expression | expression &apos;|&apos; expression | expression &apos;&amp;&amp;&apos; expression | expression &apos;||&apos; expression | expression &apos;?&apos; expression &apos;:&apos; expression | expression (&apos;^=&apos;&lt;assoc=right&gt; |&apos;+=&apos;&lt;assoc=right&gt; |&apos;-=&apos;&lt;assoc=right&gt; |&apos;*=&apos;&lt;assoc=right&gt; |&apos;/=&apos;&lt;assoc=right&gt; |&apos;&amp;=&apos;&lt;assoc=right&gt; |&apos;|=&apos;&lt;assoc=right&gt; |&apos;=&apos;&lt;assoc=right&gt; |&apos;&gt;&apos; &apos;&gt;&apos; &apos;=&apos;&lt;assoc=right&gt; |&apos;&gt;&apos; &apos;&gt;&apos; &apos;&gt;&apos; &apos;=&apos;&lt;assoc=right&gt; |&apos;&lt;&apos; &apos;&lt;&apos; &apos;=&apos;&lt;assoc=right&gt; |&apos;%=&apos;&lt;assoc=right&gt; ) expression ;primary : &apos;(&apos; expression &apos;)&apos; | &apos;this&apos; | &apos;super&apos; | literal | Identifier | type &apos;.&apos; &apos;class&apos; | &apos;void&apos; &apos;.&apos; &apos;class&apos; ;creator : nonWildcardTypeArguments createdName classCreatorRest | createdName (arrayCreatorRest | classCreatorRest) ;createdName : classOrInterfaceType | primitiveType ;innerCreator : nonWildcardTypeArguments? Identifier classCreatorRest ;explicitGenericInvocation : nonWildcardTypeArguments Identifier arguments ;arrayCreatorRest : &apos;[&apos; ( &apos;]&apos; (&apos;[&apos; &apos;]&apos;)* arrayInitializer | expression &apos;]&apos; (&apos;[&apos; expression &apos;]&apos;)* (&apos;[&apos; &apos;]&apos;)* ) ;classCreatorRest : arguments classBody? ;nonWildcardTypeArguments : &apos;&lt;&apos; typeList &apos;&gt;&apos; ;arguments : &apos;(&apos; expressionList? &apos;)&apos; ;// LEXERHexLiteral : &apos;0&apos; (&apos;x&apos;|&apos;X&apos;) HexDigit+ IntegerTypeSuffix? ;DecimalLiteral : (&apos;0&apos; | &apos;1&apos;..&apos;9&apos; &apos;0&apos;..&apos;9&apos;*) IntegerTypeSuffix? ;OctalLiteral : &apos;0&apos; (&apos;0&apos;..&apos;7&apos;)+ IntegerTypeSuffix? ;fragmentHexDigit : (&apos;0&apos;..&apos;9&apos;|&apos;a&apos;..&apos;f&apos;|&apos;A&apos;..&apos;F&apos;) ;fragmentIntegerTypeSuffix : (&apos;l&apos;|&apos;L&apos;) ;FloatingPointLiteral : (&apos;0&apos;..&apos;9&apos;)+ &apos;.&apos; (&apos;0&apos;..&apos;9&apos;)* Exponent? FloatTypeSuffix? | &apos;.&apos; (&apos;0&apos;..&apos;9&apos;)+ Exponent? FloatTypeSuffix? | (&apos;0&apos;..&apos;9&apos;)+ Exponent FloatTypeSuffix? | (&apos;0&apos;..&apos;9&apos;)+ FloatTypeSuffix | (&apos;0x&apos; | &apos;0X&apos;) (HexDigit )* (&apos;.&apos; (HexDigit)*)? ( &apos;p&apos; | &apos;P&apos; ) ( &apos;+&apos; | &apos;-&apos; )? ( &apos;0&apos; .. &apos;9&apos; )+ FloatTypeSuffix? ;fragmentExponent : (&apos;e&apos;|&apos;E&apos;) (&apos;+&apos;|&apos;-&apos;)? (&apos;0&apos;..&apos;9&apos;)+ ;fragmentFloatTypeSuffix : (&apos;f&apos;|&apos;F&apos;|&apos;d&apos;|&apos;D&apos;) ;CharacterLiteral : &apos;\&apos;&apos; ( EscapeSequence | ~(&apos;\&apos;&apos;|&apos;\\&apos;) ) &apos;\&apos;&apos; ;StringLiteral : &apos;&quot;&apos; ( EscapeSequence | ~(&apos;\\&apos;|&apos;&quot;&apos;) )* &apos;&quot;&apos; ;fragmentEscapeSequence : &apos;\\&apos; (&apos;b&apos;|&apos;t&apos;|&apos;n&apos;|&apos;f&apos;|&apos;r&apos;|&apos;\&quot;&apos;|&apos;\&apos;&apos;|&apos;\\&apos;) | UnicodeEscape | OctalEscape ;fragmentOctalEscape : &apos;\\&apos; (&apos;0&apos;..&apos;3&apos;) (&apos;0&apos;..&apos;7&apos;) (&apos;0&apos;..&apos;7&apos;) | &apos;\\&apos; (&apos;0&apos;..&apos;7&apos;) (&apos;0&apos;..&apos;7&apos;) | &apos;\\&apos; (&apos;0&apos;..&apos;7&apos;) ;fragmentUnicodeEscape : &apos;\\&apos; &apos;u&apos; HexDigit HexDigit HexDigit HexDigit ;ENUM: &apos;enum&apos; &#123;if (!enumIsKeyword) setType(Identifier);&#125; ;ASSERT : &apos;assert&apos; &#123;if (!assertIsKeyword) setType(Identifier);&#125; ;Identifier : Letter (Letter|JavaIDDigit)* ;/**I found this char range in JavaCC&apos;s grammar, but Letter and Digit overlap. Still works, but... */fragmentLetter : &apos;\u0024&apos; | &apos;\u0041&apos;..&apos;\u005a&apos; | &apos;\u005f&apos; | &apos;\u0061&apos;..&apos;\u007a&apos; | &apos;\u00c0&apos;..&apos;\u00d6&apos; | &apos;\u00d8&apos;..&apos;\u00f6&apos; | &apos;\u00f8&apos;..&apos;\u00ff&apos; | &apos;\u0100&apos;..&apos;\u1fff&apos; | &apos;\u3040&apos;..&apos;\u318f&apos; | &apos;\u3300&apos;..&apos;\u337f&apos; | &apos;\u3400&apos;..&apos;\u3d2d&apos; | &apos;\u4e00&apos;..&apos;\u9fff&apos; | &apos;\uf900&apos;..&apos;\ufaff&apos; ;fragmentJavaIDDigit : &apos;\u0030&apos;..&apos;\u0039&apos; | &apos;\u0660&apos;..&apos;\u0669&apos; | &apos;\u06f0&apos;..&apos;\u06f9&apos; | &apos;\u0966&apos;..&apos;\u096f&apos; | &apos;\u09e6&apos;..&apos;\u09ef&apos; | &apos;\u0a66&apos;..&apos;\u0a6f&apos; | &apos;\u0ae6&apos;..&apos;\u0aef&apos; | &apos;\u0b66&apos;..&apos;\u0b6f&apos; | &apos;\u0be7&apos;..&apos;\u0bef&apos; | &apos;\u0c66&apos;..&apos;\u0c6f&apos; | &apos;\u0ce6&apos;..&apos;\u0cef&apos; | &apos;\u0d66&apos;..&apos;\u0d6f&apos; | &apos;\u0e50&apos;..&apos;\u0e59&apos; | &apos;\u0ed0&apos;..&apos;\u0ed9&apos; | &apos;\u1040&apos;..&apos;\u1049&apos; ;COMMENT : &apos;/*&apos; .*? &apos;*/&apos; -&gt; channel(HIDDEN) // match anything between /* and */ ;WS : [ \r\t\u000C\n]+ -&gt; channel(HIDDEN) ;LINE_COMMENT : &apos;//&apos; ~[\r\n]* &apos;\r&apos;? &apos;\n&apos; -&gt; channel(HIDDEN) ; 1234567891011121314151617181920212223242526272829303132333435363738394041//: ExtractInterfaceListener.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.TokenStream;import org.antlr.v4.runtime.misc.Interval;public class ExtractInterfaceListener extends JavaBaseListener &#123; JavaParser parser; public ExtractInterfaceListener(JavaParser parser) &#123;this.parser = parser;&#125; /** Listen to matches of classDeclaration */ @Override public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123; System.out.println("interface I"+ctx.Identifier()+" &#123;"); &#125; @Override public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123; System.out.println("&#125;"); &#125; /** Listen to matches of methodDeclaration */ @Override public void enterMethodDeclaration( JavaParser.MethodDeclarationContext ctx ) &#123; // need parser to get tokens TokenStream tokens = parser.getTokenStream(); String type = "void"; if ( ctx.type()!=null ) &#123; type = tokens.getText(ctx.type()); &#125; String args = tokens.getText(ctx.formalParameters()); System.out.println("\t"+type+" "+ctx.Identifier()+args+";"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738//: ExtractInterfaceTool.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.ANTLRInputStream;import org.antlr.v4.runtime.CommonTokenStream;import org.antlr.v4.runtime.ParserRuleContext;import org.antlr.v4.runtime.Token;import org.antlr.v4.runtime.tree.*;import java.io.FileInputStream;import java.io.InputStream;public class ExtractInterfaceTool &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) &#123; is = new FileInputStream(inputFile); &#125; ANTLRInputStream input = new ANTLRInputStream(is); JavaLexer lexer = new JavaLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); JavaParser parser = new JavaParser(tokens); ParseTree tree = parser.compilationUnit(); // parse ParseTreeWalker walker = new ParseTreeWalker(); // create standard walker ExtractInterfaceListener extractor = new ExtractInterfaceListener(parser); walker.walk(extractor, tree); // initiate walk of tree with listener &#125;&#125; 1234567891011//: Demo.javaimport java.util.List;import java.util.Map;public class Demo &#123; void f(int x, String y) &#123; &#125; int[ ] g(/*no args*/) &#123; return null; &#125; List&lt;Map&lt;String, Integer&gt;&gt;[] h() &#123; return null; &#125;&#125; 123456$ java ExtractInterfaceTool Demo.javainterface IDemo&#123; void f(int x, String y); int[ ] g(/*no args*/); List&lt;Map&lt;String, Integer&gt;&gt;[] h();&#125; Rows12345678910111213141516171819202122232425grammar Rows;@parser::members &#123; // add members to generated RowsParser int col; public RowsParser(TokenStream input, int col) &#123; // custom constructor this(input); this.col = col; &#125;&#125;file: (row NL)+ ;rowlocals [int i=0] : ( STUFF &#123; $i++; if ( $i == col ) System.out.println($STUFF.text); &#125; )+ ;TAB : &apos;\t&apos; -&gt; skip ; // match but don&apos;t pass to the parserNL : &apos;\r&apos;? &apos;\n&apos; ; // match and pass to the parserSTUFF: ~[\t\r\n]+ ; // match any chars except tab, newline 12345678910111213141516171819202122232425262728//: Col.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.ANTLRInputStream;import org.antlr.v4.runtime.CommonTokenStream;import org.antlr.v4.runtime.ParserRuleContext;import org.antlr.v4.runtime.Token;import java.io.FileInputStream;import java.io.InputStream;public class Col &#123; public static void main(String[] args) throws Exception &#123; ANTLRInputStream input = new ANTLRInputStream(System.in); RowsLexer lexer = new RowsLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); int col = Integer.valueOf(args[0]); RowsParser parser = new RowsParser(tokens, col); // pass column number! parser.setBuildParseTree(false); // don't waste time bulding a tree parser.file(); // parse &#125;&#125; 123parrt Terence Parr 101tombu Tom Burns 020bke Kevin Edgar 008 chap6CSV1234567891011121314151617// CSV.g4grammar CSV;file : hdr row+ ;hdr : row ;row : field (&apos;,&apos; field)* &apos;\r&apos;? &apos;\n&apos; ;field : TEXT | STRING | ;TEXT : ~[,\n\r&quot;]+ ;STRING: &apos;&quot;&apos; (&apos;&quot;&quot;&apos;|~&apos;&quot;&apos;)* &apos;&quot;&apos; ; 1234Details,Month,AmountMid Bonus,June,&quot;$2,000&quot;,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;Total Bonuses,&quot;&quot;,&quot;$5,000&quot; JSON123456789101112131415161718192021222324252627282930313233343536373839404142434445// JSON.g4// Derived from http://json.orggrammar JSON;json: object | array ;object : &apos;&#123;&apos; pair (&apos;,&apos; pair)* &apos;&#125;&apos; | &apos;&#123;&apos; &apos;&#125;&apos; // empty object ;pair: STRING &apos;:&apos; value ;array : &apos;[&apos; value (&apos;,&apos; value)* &apos;]&apos; | &apos;[&apos; &apos;]&apos; // empty array ;value : STRING | NUMBER | object // recursion | array // recursion | &apos;true&apos; // keywords | &apos;false&apos; | &apos;null&apos; ;STRING : &apos;&quot;&apos; (ESC | ~[&quot;\\])* &apos;&quot;&apos; ;fragment ESC : &apos;\\&apos; ([&quot;\\/bfnrt] | UNICODE) ;fragment UNICODE : &apos;u&apos; HEX HEX HEX HEX ;fragment HEX : [0-9a-fA-F] ;NUMBER : &apos;-&apos;? INT &apos;.&apos; [0-9]+ EXP? // 1.35, 1.35E-9, 0.3, -4.5 | &apos;-&apos;? INT EXP // 1e10 -3e4 | &apos;-&apos;? INT // -3, 45 ;fragment INT : &apos;0&apos; | [1-9] [0-9]* ; // no leading zerosfragment EXP : [Ee] [+\-]? INT ; // \- since - means &quot;range&quot; inside [...]WS : [ \t\n\r]+ -&gt; skip ; 12345678&#123; "antlr.org": &#123; "owners" : [], "live" : true, "speed" : 145, "menus" : ["File", "Help\nMenu"] &#125;&#125; chap7PropertyFile12345678910grammar PropertyFile;@members &#123;void startFile() &#123; &#125; // blank implementationsvoid finishFile() &#123; &#125;void defineProperty(Token name, Token value) &#123; &#125;&#125;file : &#123;startFile();&#125; prop+ &#123;finishFile();&#125; ;prop : ID &apos;=&apos; STRING &apos;\n&apos; &#123;defineProperty($ID, $STRING);&#125; ;ID : [a-z]+ ;STRING : &apos;&quot;&apos; .*? &apos;&quot;&apos; ; 123456789101112131415161718192021222324252627282930313233343536373839//: PropertyFileRide.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.FileInputStream;import java.io.InputStream;class PropertyFilePrinter extends PropertyFileParser &#123; public PropertyFilePrinter(TokenStream input) &#123; super(input); &#125; @Override void defineProperty(Token name, Token value) &#123; System.out.println(name.getText()+"="+value.getText()); &#125;&#125;public class PropertyFileRide &#123; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); PropertyFileLexer lexer = new PropertyFileLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); PropertyFilePrinter parser = new PropertyFilePrinter(tokens); parser.file(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//: TestPropertyFile.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import org.antlr.v4.misc.OrderedHashMap;import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.*;import java.util.Map;public class TestPropertyFile &#123; public static class PropertyFileLoader extends PropertyFileBaseListener &#123; Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;(); public void exitProp(PropertyFileParser.PropContext ctx) &#123; String id = ctx.ID().getText(); // prop : ID '=' STRING '\n' ; String value = ctx.STRING().getText(); props.put(id, value); &#125; &#125; public static void main(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) &#123; is = new FileInputStream(inputFile); &#125; ANTLRInputStream input = new ANTLRInputStream(is); PropertyFileLexer lexer = new PropertyFileLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); PropertyFileParser parser = new PropertyFileParser(tokens); ParseTree tree = parser.file(); // create a standard ANTLR parse tree walker ParseTreeWalker walker = new ParseTreeWalker(); // create listener then feed to walker PropertyFileLoader loader = new PropertyFileLoader(); walker.walk(loader, tree); // walk parse tree System.out.println(loader.props); // print results &#125;&#125; 12user=&quot;parrt&quot;machine=&quot;maniac&quot; PropertyFile212345grammar PropertyFile;file : prop+ ;prop : ID &apos;=&apos; STRING &apos;\n&apos; ;ID : [a-z]+ ;STRING : &apos;&quot;&apos; .*? &apos;&quot;&apos; ; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//: TestPropertyFile.java/** * @author jumormt * @version 1.0 */import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import org.antlr.v4.misc.OrderedHashMap;import java.io.FileInputStream;import java.io.InputStream;import java.util.HashMap;import java.util.Map;public class TestPropertyFile&#123; public static class PropertyFileLoader extends PropertyFileBaseVisitor&lt;Integer&gt;&#123; Map&lt;String, String&gt; prps = new OrderedHashMap&lt;String, String&gt;(); @Override public Integer visitProp(PropertyFileParser.PropContext ctx) &#123; String id = ctx.ID().getText(); String value = ctx.STRING().getText(); prps.put(id, value); return 0; &#125; &#125; public static void main(String[] args) throws Exception&#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); PropertyFileLexer lexer = new PropertyFileLexer(new ANTLRInputStream(is)); CommonTokenStream tokens = new CommonTokenStream(lexer); PropertyFileParser parser = new PropertyFileParser(tokens); parser.setBuildParseTree(true); // tell ANTLR to build a parse tree ParseTree tree = parser.file(); PropertyFileLoader loader = new PropertyFileLoader(); loader.visit(tree); System.out.println(loader.prps); &#125;&#125; chap8LoadCSV123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//: LoadCSV.java/** chap8/8.1 * @author jumormt * @version 1.0 */import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.*;import java.util.*;public class LoadCSV&#123; public static class Loader extends CSVBaseListener&#123; public static final String EMPTY = ""; List&lt;Map&lt;String, String&gt;&gt; rows = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); List&lt;String&gt; header; List&lt;String&gt; currentRowFieldVaule; @Override public void exitEmpty(CSVParser.EmptyContext ctx) &#123; currentRowFieldVaule.add(EMPTY); &#125; @Override public void exitString(CSVParser.StringContext ctx) &#123; currentRowFieldVaule.add(ctx.STRING().getText()); &#125; @Override public void exitText(CSVParser.TextContext ctx) &#123; currentRowFieldVaule.add(ctx.TEXT().getText()); &#125; @Override public void exitHdr(CSVParser.HdrContext ctx) &#123; header = new ArrayList&lt;String&gt;(); header.addAll(currentRowFieldVaule); &#125; @Override public void enterRow(CSVParser.RowContext ctx) &#123; currentRowFieldVaule = new ArrayList&lt;String&gt;(); &#125; @Override public void exitRow(CSVParser.RowContext ctx) &#123; if (ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr)&#123; return; &#125; Map&lt;String, String&gt; mp = new LinkedHashMap&lt;String, String&gt;(); int i = 0; for (String v : currentRowFieldVaule)&#123; mp.put(header.get(i), v); ++i; &#125; rows.add(mp); &#125; &#125; public static void main(String[] args) throws Exception&#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); CSVLexer lexer = new CSVLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); CSVParser paser = new CSVParser(tokens); ParseTree tree = paser.file(); ParseTreeWalker walker = new ParseTreeWalker(); Loader loader = new Loader(); walker.walk(loader, tree); System.out.println(loader.rows); &#125;&#125; JSON2XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//:JSON2XML.javaimport org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import java.io.*;import java.util.*;/** chap8/8.2 * @author jumormt * @version 1.0 */public class JSON2XML&#123; public static class XMLEmitter extends JSONBaseListener&#123; ParseTreeProperty&lt;String&gt; xml = new ParseTreeProperty&lt;String&gt;(); void setXml(ParseTree t, String v) &#123;xml.put(t, v);&#125; String getXml(ParseTree t)&#123;return xml.get(t);&#125; @Override public void exitJson(JSONParser.JsonContext ctx) &#123; setXml(ctx, getXml(ctx.getChild(0))); &#125; @Override public void exitEmptyArray(JSONParser.EmptyArrayContext ctx) &#123; setXml(ctx, ""); &#125; @Override public void exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) &#123; StringBuilder buf = new StringBuilder(); buf.append('\n'); for (JSONParser.ValueContext p:ctx.value())&#123; buf.append("&lt;element&gt;"); buf.append(getXml(p)); buf.append("&lt;/element&gt;"); buf.append('\n'); &#125; setXml(ctx, buf.toString()); &#125; @Override public void exitEmptyObject(JSONParser.EmptyObjectContext ctx) &#123; setXml(ctx, ""); &#125; @Override public void exitAnObject(JSONParser.AnObjectContext ctx) &#123; StringBuilder buf = new StringBuilder(); buf.append('\n'); for (JSONParser.PairContext p:ctx.pair())&#123; buf.append(getXml(p)); &#125; setXml(ctx, buf.toString()); &#125; @Override public void exitPair(JSONParser.PairContext ctx) &#123; String tag = stripQuotes(ctx.STRING().getText()); JSONParser.ValueContext cvalue = ctx.value(); String x = String.format("&lt;%s&gt;%s&lt;/%s&gt;\n", tag, getXml(cvalue), tag); setXml(ctx, x); &#125; @Override public void exitString(JSONParser.StringContext ctx) &#123; setXml(ctx, stripQuotes(ctx.getText())); &#125; @Override public void exitAtom(JSONParser.AtomContext ctx) &#123; setXml(ctx, ctx.getText()); &#125; @Override public void exitObjectValue(JSONParser.ObjectValueContext ctx) &#123; setXml(ctx, getXml(ctx.object())); &#125; @Override public void exitArrayValue(JSONParser.ArrayValueContext ctx) &#123; setXml(ctx, getXml(ctx.array())); &#125; public static String stripQuotes(String s) &#123; if ( s==null || s.charAt(0)!='"' ) return s; return s.substring(1, s.length() - 1); &#125; &#125; public static void main(String[] args) throws Exception&#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) is = new FileInputStream(inputFile); ANTLRInputStream input = new ANTLRInputStream(is); JSONLexer lexer = new JSONLexer(input); CommonTokenStream tokenStream = new CommonTokenStream(lexer); JSONParser parser = new JSONParser(tokenStream); ParseTree tree = parser.json(); ParseTreeWalker walker = new ParseTreeWalker(); XMLEmitter xmlEmitter = new XMLEmitter(); walker.walk(xmlEmitter, tree); System.out.println(xmlEmitter.getXml(tree)); &#125;&#125; CALLGRAPH123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//: CallGraph.java/** chap8/8.3 * @author jumormt * @version 1.0 */import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.tree.*;import org.antlr.v4.runtime.misc.*;import java.io.*;import java.util.*;public class CallGraph &#123; /** 调用图 */ static class Graph&#123; Set&lt;String&gt; nodes = new OrderedHashSet&lt;String&gt;(); MultiMap&lt;String, String&gt; edges = new MultiMap&lt;String, String&gt;(); public void edge(String source, String dest)&#123; edges.map(source, dest); &#125; public String toDOT() &#123; StringBuilder buf = new StringBuilder(); buf.append("digraph G &#123;\n"); buf.append(" ranksep=.25;\n"); buf.append(" edge [arrowsize=.5]\n"); buf.append(" node [shape=circle, fontname=\"ArialNarrow\",\n"); buf.append(" fontsize=12, fixedsize=true, height=.45];\n"); buf.append(" "); for (String node : nodes) &#123; // print all nodes first buf.append(node); buf.append("; "); &#125; buf.append("\n"); for (String src : edges.keySet()) &#123; for (String trg : edges.get(src)) &#123; buf.append(" "); buf.append(src); buf.append(" -&gt; "); buf.append(trg); buf.append(";\n"); &#125; &#125; buf.append("&#125;\n"); return buf.toString(); &#125; &#125; public static class FunctionListener extends CymbolBaseListener&#123; Graph gp = new Graph(); String currentFunctionName = null; @Override public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) &#123; currentFunctionName = ctx.ID().getText(); gp.nodes.add(currentFunctionName); &#125; @Override public void exitCall(CymbolParser.CallContext ctx) &#123; String functionName = ctx.ID().getText(); gp.edge(currentFunctionName, functionName); &#125; &#125; public static void main(String[] args) throws Exception&#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) &#123; is = new FileInputStream(inputFile); &#125; ANTLRInputStream input = new ANTLRInputStream(is); CymbolLexer lexer = new CymbolLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); CymbolParser parser = new CymbolParser(tokens); parser.setBuildParseTree(true); ParseTree tree = parser.file(); // show tree in text form// System.out.println(tree.toStringTree(parser)); ParseTreeWalker walker = new ParseTreeWalker(); FunctionListener collector = new FunctionListener(); walker.walk(collector, tree); System.out.println(collector.gp.toString()); System.out.println(collector.gp.toDOT()); // Here's another example that uses StringTemplate to generate output// System.out.println(collector.graph.toST().render()); &#125;&#125; DRefPhase12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Cymbol.g4/** Simple statically-typed programming language with functions and variables * taken from &quot;Language Implementation Patterns&quot; book. */grammar Cymbol;file: (functionDecl | varDecl)+ ;varDecl : type ID (&apos;=&apos; expr)? &apos;;&apos; ;type: &apos;float&apos; | &apos;int&apos; | &apos;void&apos; ; // user-defined typesfunctionDecl : type ID &apos;(&apos; formalParameters? &apos;)&apos; block // &quot;void f(int x) &#123;...&#125;&quot; ;formalParameters : formalParameter (&apos;,&apos; formalParameter)* ;formalParameter : type ID ;block: &apos;&#123;&apos; stat* &apos;&#125;&apos; ; // possibly empty statement blockstat: block | varDecl | &apos;if&apos; expr &apos;then&apos; stat (&apos;else&apos; stat)? | &apos;return&apos; expr? &apos;;&apos; | expr &apos;=&apos; expr &apos;;&apos; // assignment | expr &apos;;&apos; // func call ;/* expr below becomes the following non-left recursive rule:expr[int _p] : ( &apos;-&apos; expr[6] | &apos;!&apos; expr[5] | ID | INT | &apos;(&apos; expr &apos;)&apos; ) ( &#123;8 &gt;= $_p&#125;? &apos;*&apos; expr[9] | &#123;7 &gt;= $_p&#125;? (&apos;+&apos;|&apos;-&apos;) expr[8] | &#123;4 &gt;= $_p&#125;? &apos;==&apos; expr[5] | &#123;10 &gt;= $_p&#125;? &apos;[&apos; expr &apos;]&apos; | &#123;9 &gt;= $_p&#125;? &apos;(&apos; exprList? &apos;)&apos; )* ;*/expr: ID &apos;(&apos; exprList? &apos;)&apos; # Call | expr &apos;[&apos; expr &apos;]&apos; # Index | &apos;-&apos; expr # Negate | &apos;!&apos; expr # Not | expr &apos;*&apos; expr # Mult | expr (&apos;+&apos;|&apos;-&apos;) expr # AddSub | expr &apos;==&apos; expr # Equal | ID # Var | INT # Int | &apos;(&apos; expr &apos;)&apos; # Parens ;exprList : expr (&apos;,&apos; expr)* ; // arg listK_FLOAT : &apos;float&apos;;K_INT : &apos;int&apos;;K_VOID : &apos;void&apos;;ID : LETTER (LETTER | [0-9])* ;fragmentLETTER : [a-zA-Z] ;INT : [0-9]+ ;WS : [ \t\n\r]+ -&gt; skip ;SL_COMMENT : &apos;//&apos; .*? &apos;\n&apos; -&gt; skip ; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//: DefPhase.javaimport SymbolList.*;import org.antlr.v4.runtime.tree.*;import org.antlr.v4.runtime.*;public class DefPhase extends CymbolBaseListener&#123; ParseTreeProperty&lt;Scope&gt; scopes = new ParseTreeProperty&lt;Scope&gt;(); GlobalScope globals; Scope currentScope; @Override public void enterFile(CymbolParser.FileContext ctx) &#123; globals = new GlobalScope(null); currentScope = globals; &#125; @Override public void exitFile(CymbolParser.FileContext ctx) &#123; System.out.println(globals); &#125; @Override public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) &#123; String name = ctx.ID().getText(); int typeTokenType = ctx.type().start.getType(); Symbol.Type type = CheckSymbols.getType(typeTokenType); // push new scope by making new one that points to enclosing scope FunctionSymbol function = new FunctionSymbol(name, type, currentScope); currentScope.define(function); // Define function in current scope saveScope(ctx, function); // Push: set function's parent to current currentScope = function; // Current scope is now function scope &#125; void saveScope(ParserRuleContext ctx, Scope s) &#123; scopes.put(ctx, s); &#125; @Override public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) &#123; System.out.println(currentScope); currentScope = currentScope.getEnclosingScope(); &#125; public void enterBlock(CymbolParser.BlockContext ctx) &#123; // push new local scope currentScope = new LocalScope(currentScope); saveScope(ctx, currentScope); &#125; public void exitBlock(CymbolParser.BlockContext ctx) &#123; System.out.println(currentScope); currentScope = currentScope.getEnclosingScope(); // pop scope &#125; public void exitFormalParameter(CymbolParser.FormalParameterContext ctx) &#123; defineVar(ctx.type(), ctx.ID().getSymbol()); &#125; public void exitVarDecl(CymbolParser.VarDeclContext ctx) &#123; defineVar(ctx.type(), ctx.ID().getSymbol()); &#125; void defineVar(CymbolParser.TypeContext typeCtx, Token nameToken) &#123; int typeTokenType = typeCtx.start.getType(); Symbol.Type type = CheckSymbols.getType(typeTokenType); VariableSymbol var = new VariableSymbol(nameToken.getText(), type); currentScope.define(var); // Define symbol in current scope &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//: RefPhase.java/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/import org.antlr.v4.runtime.tree.ParseTreeProperty;import SymbolList.*;public class RefPhase extends CymbolBaseListener &#123; ParseTreeProperty&lt;Scope&gt; scopes; GlobalScope globals; Scope currentScope; // resolve symbols starting in this scope public RefPhase(GlobalScope globals, ParseTreeProperty&lt;Scope&gt; scopes) &#123; this.scopes = scopes; this.globals = globals; &#125; public void enterFile(CymbolParser.FileContext ctx) &#123; currentScope = globals; &#125; public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) &#123; currentScope = scopes.get(ctx); &#125; public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) &#123; currentScope = currentScope.getEnclosingScope(); &#125; public void enterBlock(CymbolParser.BlockContext ctx) &#123; currentScope = scopes.get(ctx); &#125; public void exitBlock(CymbolParser.BlockContext ctx) &#123; currentScope = currentScope.getEnclosingScope(); &#125; public void exitVar(CymbolParser.VarContext ctx) &#123; String name = ctx.ID().getSymbol().getText(); Symbol var = currentScope.resolve(name); if ( var==null ) &#123; CheckSymbols.error(ctx.ID().getSymbol(), "no such variable: "+name); &#125; if ( var instanceof FunctionSymbol ) &#123; CheckSymbols.error(ctx.ID().getSymbol(), name+" is not a variable"); &#125; &#125; public void exitCall(CymbolParser.CallContext ctx) &#123; // can only handle f(...) not expr(...) String funcName = ctx.ID().getText(); Symbol meth = currentScope.resolve(funcName); if ( meth==null ) &#123; CheckSymbols.error(ctx.ID().getSymbol(), "no such function: "+funcName); &#125; if ( meth instanceof VariableSymbol ) &#123; CheckSymbols.error(ctx.ID().getSymbol(), funcName+" is not a function"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//: CheckSymbols.java/** chap8/8.4 main * @author jumormt * @version 1.0 *//*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/import org.antlr.v4.runtime.ANTLRInputStream;import org.antlr.v4.runtime.CommonTokenStream;import org.antlr.v4.runtime.ParserRuleContext;import org.antlr.v4.runtime.Token;import org.antlr.v4.runtime.tree.*;import java.io.FileInputStream;import java.io.InputStream;import SymbolList.*;public class CheckSymbols &#123; public static Symbol.Type getType(int tokenType) &#123; switch ( tokenType ) &#123; case CymbolParser.K_VOID : return Symbol.Type.tVOID; case CymbolParser.K_INT : return Symbol.Type.tINT; case CymbolParser.K_FLOAT : return Symbol.Type.tFLOAT; &#125; return Symbol.Type.tINVALID; &#125; public static void error(Token t, String msg) &#123; System.err.printf("line %d:%d %s\n", t.getLine(), t.getCharPositionInLine(), msg); &#125; public void process(String[] args) throws Exception &#123; String inputFile = null; if ( args.length&gt;0 ) inputFile = args[0]; InputStream is = System.in; if ( inputFile!=null ) &#123; is = new FileInputStream(inputFile); &#125; ANTLRInputStream input = new ANTLRInputStream(is); CymbolLexer lexer = new CymbolLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); CymbolParser parser = new CymbolParser(tokens); parser.setBuildParseTree(true); ParseTree tree = parser.file(); // show tree in text form// System.out.println(tree.toStringTree(parser)); ParseTreeWalker walker = new ParseTreeWalker(); DefPhase def = new DefPhase(); walker.walk(def, tree); // create next phase and feed symbol table info from def to ref phase RefPhase ref = new RefPhase(def.globals, def.scopes); walker.walk(ref, tree); &#125; public static void main(String[] args) throws Exception &#123; new CheckSymbols().process(args); &#125;&#125; 123456789101112131415161718192021222324252627282930//vars.cymbolint f(int x, float y) &#123; g(); // forward reference is ok i = 3; // no declaration for i (error) g = 4; // g is not variable (error) return x + y; // x, y are defined, so no problem&#125;void g() &#123; int x = 0; float y; y = 9; // y is defined f(); // backward reference is ok z(); // no such function (error) y(); // y is not function (error) x = f; // f is not a variable (error)&#125;//vars2.cymbolint x; //(1)int y;void a() //(2)&#123; //(3) int x; x = 1; // x resolves to current scope, not x in global scope y = 2; // y is not found in current scope, but resolves in global &#123; int y = x; &#125; //(4)&#125;void b(int z) //(5)&#123; &#125; //(6) SymbolList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//: Scope.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/public interface Scope &#123; public String getScopeName(); /** Where to look next for symbols */ public Scope getEnclosingScope(); /** Define a symbol in the current scope */ public void define(Symbol sym); /** Look up name in this scope or in enclosing scope if not here */ public Symbol resolve(String name);&#125;//: BaseScope.javapackage SymbolList;import java.util.LinkedHashMap;import java.util.Map;public abstract class BaseScope implements Scope &#123; Scope enclosingScope; // null if global (outermost) scope Map&lt;String, Symbol&gt; symbols = new LinkedHashMap&lt;String, Symbol&gt;(); public BaseScope(Scope enclosingScope) &#123; this.enclosingScope = enclosingScope; &#125; public Symbol resolve(String name) &#123; Symbol s = symbols.get(name); if ( s!=null ) return s; // if not here, check any enclosing scope if ( enclosingScope != null ) return enclosingScope.resolve(name); return null; // not found &#125; public void define(Symbol sym) &#123; symbols.put(sym.name, sym); sym.scope = this; // track the scope in each symbol &#125; public Scope getEnclosingScope() &#123; return enclosingScope; &#125; public String toString() &#123; return getScopeName()+":"+symbols.keySet().toString(); &#125;&#125;//: SymbolList/GlobalScope.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/public class GlobalScope extends BaseScope &#123; public GlobalScope(Scope enclosingScope) &#123; super(enclosingScope); &#125; public String getScopeName() &#123; return "globals"; &#125;&#125;//: SymbolList/LocalScope.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/public class LocalScope extends BaseScope &#123; public LocalScope(Scope parent) &#123; super(parent); &#125; public String getScopeName() &#123; return "locals"; &#125;&#125;//: Symbol.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/public class Symbol &#123; // A generic programming language symbol public static enum Type &#123;tINVALID, tVOID, tINT, tFLOAT&#125; String name; // All symbols at least have a name Type type; Scope scope; // All symbols know what scope contains them. public Symbol(String name) &#123; this.name = name; &#125; public Symbol(String name, Type type) &#123; this(name); this.type = type; &#125; public String getName() &#123; return name; &#125; public String toString() &#123; if ( type!=Type.tINVALID ) return '&lt;'+getName()+":"+type+'&gt;'; return getName(); &#125;&#125;//: FunctionSymbol.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***/import java.util.LinkedHashMap;import java.util.Map;public class FunctionSymbol extends Symbol implements Scope &#123; Map&lt;String, Symbol&gt; arguments = new LinkedHashMap&lt;String, Symbol&gt;(); Scope enclosingScope; public FunctionSymbol(String name, Type retType, Scope enclosingScope) &#123; super(name, retType); this.enclosingScope = enclosingScope; &#125; public Symbol resolve(String name) &#123; Symbol s = arguments.get(name); if ( s!=null ) return s; // if not here, check any enclosing scope if ( getEnclosingScope() != null ) &#123; return getEnclosingScope().resolve(name); &#125; return null; // not found &#125; public void define(Symbol sym) &#123; arguments.put(sym.name, sym); sym.scope = this; // track the scope in each symbol &#125; public Scope getEnclosingScope() &#123; return enclosingScope; &#125; public String getScopeName() &#123; return name; &#125; public String toString() &#123; return "function"+super.toString()+":"+arguments.values(); &#125;&#125;//: VariableSymbol.javapackage SymbolList;/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material, * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose. * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information. ***//** Represents a variable definition (name,type) in symbol table */public class VariableSymbol extends Symbol &#123; public VariableSymbol(String name, Type type) &#123; super(name, type); &#125;&#125;]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB学习]]></title>
    <url>%2F2018%2F08%2F24%2FGDB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[源码检测包括代码检查、静态结构分析、代码质量度量等。它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具自动进行。 GDB使用入门 gdb 调试入门，大牛写的高质量指南]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>动态分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-访问者模式入门]]></title>
    <url>%2F2018%2F07%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8Fe%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[访问者模式是设计模式中的一种 参考文献 极速理解设计模式系列：18.访问者模式(Visitor Pattern) JAVA设计模式之Visitor模式 Visitor模式详解–设计模式]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-观察者模式入门]]></title>
    <url>%2F2018%2F07%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[观察者模式是设计模式中的一种，文转自观察者模式 模式动机建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。 模式定义观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 观察者模式是一种对象行为型模式。 模式结构观察者模式包含如下角色： Subject: 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver: 具体观察者 时序图 代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// Subject.h// Created by 程潇 on 2018/7/10.//#ifndef PRACTICE_CLION_SUBJECT_H#define PRACTICE_CLION_SUBJECT_H#include "Obeserver.h"#include &lt;vector&gt;using namespace std;class Subject&#123;public: Subject(); virtual ~Subject(); Obeserver *m_Obeserver; void attach(Obeserver * pObeserver); void detach(Obeserver * pObeserver); void notify(); virtual int getState() = 0; virtual void setState(int i)= 0;private: vector&lt;Obeserver*&gt; m_vtObj; int subState;&#125;;#endif //PRACTICE_CLION_SUBJECT_H// Subject.cpp// Created by 程潇 on 2018/7/10.//#include "Subject.h"Subject::Subject()&#123;&#125;Subject::~Subject()&#123;&#125;void Subject::attach(Obeserver * pObeserver)&#123; m_vtObj.push_back(pObeserver);&#125;void Subject::detach(Obeserver * pObeserver)&#123; for(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.begin(); itr != m_vtObj.end(); itr++) &#123; if(*itr == pObeserver) &#123; m_vtObj.erase(itr); return; &#125; &#125;&#125;void Subject::notify()&#123; for(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.begin(); itr != m_vtObj.end(); itr++) &#123; (*itr)-&gt;update(this); &#125;&#125;// ConcreteSubject.h// Created by 程潇 on 2018/7/10.//#ifndef PRACTICE_CLION_CONCRETESUBJECT_H#define PRACTICE_CLION_CONCRETESUBJECT_H#include "Obeserver.h"#include &lt;vector&gt;#include "Subject.h"#include "string"using namespace std;class ConcreteSubject:public Subject&#123;public: ConcreteSubject(string n); virtual int getState(); virtual void setState(int i);private: int subAState; string name;&#125;;#endif //PRACTICE_CLION_CONCRETESUBJECT_H// ConcreteSubject.cpp// Created by 程潇 on 2018/7/10.//#include "ConcreteSubject.h"ConcreteSubject::ConcreteSubject(string n) &#123; name = n;&#125;int ConcreteSubject::getState()&#123; return subAState;&#125;void ConcreteSubject::setState(int i)&#123; subAState = i; notify();&#125;// Obeserver.h// Created by 程潇 on 2018/7/10.//#ifndef PRACTICE_CLION_OBESERVER_H#define PRACTICE_CLION_OBESERVER_Hclass Subject;class Obeserver &#123;public: virtual ~Obeserver()&#123; &#125; virtual void update(Subject * sub) = 0;&#125;;#endif //PRACTICE_CLION_OBESERVER_H// ConcreteObeserver.h// Created by 程潇 on 2018/7/10.//#ifndef PRACTICE_CLION_CONCRETEOBESERVER_H#define PRACTICE_CLION_CONCRETEOBESERVER_H#include "Obeserver.h"#include &lt;string&gt;using namespace std;class ConcreteObeserver : public Obeserver&#123;public: ConcreteObeserver(string name); virtual ~ConcreteObeserver(); virtual void update(Subject * sub);private: string m_objName; int m_obeserverState;&#125;;#endif //PRACTICE_CLION_CONCRETEOBESERVER_H// ConcreteObeserver.cpp// Created by 程潇 on 2018/7/10.//#include "ConcreteObeserver.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include "Subject.h"#include "ConcreteObeserver.h"using namespace std;ConcreteObeserver::ConcreteObeserver(string name)&#123; m_objName = name;&#125;ConcreteObeserver::~ConcreteObeserver()&#123;&#125;void ConcreteObeserver::update(Subject * sub)&#123; m_obeserverState = sub-&gt;getState(); cout &lt;&lt; "update oberserver[" &lt;&lt; m_objName &lt;&lt; "] state:" &lt;&lt; m_obeserverState &lt;&lt; endl;&#125;// main.cpp#include "Subject.h"#include "ConcreteObeserver.h"#include "ConcreteSubject.h"int main()&#123; Subject * subject = new ConcreteSubject("S"); Obeserver * objA = new ConcreteObeserver("A"); Obeserver * objB = new ConcreteObeserver("B"); subject-&gt;attach(objA); subject-&gt;attach(objB); subject-&gt;setState(1); cout &lt;&lt; "--------------------" &lt;&lt; endl; subject-&gt;detach(objB); subject-&gt;setState(2); delete subject; delete objA; delete objB; return 0;&#125; 模式分析-观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 优点 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合“开闭原则”的要求。 缺点 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 适用环境 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 模式应用观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式 模式扩展MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。 总结 观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。 观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。 在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpotBugs安装及使用]]></title>
    <url>%2F2018%2F07%2F06%2FSpotBugs%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpotBugs是Findbugs的继任者，Findbugs已经不再维护，不过SpotBugs继承了绝大部分Fingbugs的代码结构,他们的原理基本相同，同样利用了BCEL字节码程序设计库，这个设计库专门用于分析java字节码，且都是基于观察者模式并给予实现。 介绍官网网站 文档 SpotBugs是Findbugs的继任者（Findbugs已经不再维护），具体介绍可以参见Findbugs的安装及使用一文。 SpotBugs能够分析使用java1.0到1.9编译的程序,具备良好的扩展性，可以自定义bug pattern。 安装及使用安装 下载二进制发行版本tar或zip 解压并配置环境变量 直接运行bin目录下的可执行程序 使用官方使用描述 SpotBugs非插件版本支持gui和命令行两种使用方式,默认为gui，具体参数及使用说明参见官方使用描述。 注意：要分析的文件放在命令行的最后。 例：spotbugs -textui -low -html -output result.html /path/to/src 扩展SpotBugs具备良好的扩展性，将自定义的检测器工程打成jar包放置在plugin文件夹下便可以直接使用。 比较流行的插件：fb-contrib和Find Security Bugs 也可以自定义插件 使用spotbugs-archetype创建maven工程,填写groupid,artifitid,package name以及initial version 1234$ mvn archetype:generate \ -DarchetypeArtifactId=spotbugs-archetype \ -DarchetypeGroupId=com.github.spotbugs \ -DarchetypeVersion=0.2.0 运行完上述命令便会创建好一个maven工程,这时候可以在src/test/java文件夹下添加自定义的检测器并进行测试 在src/main/resources目录下添加fingbugs.xml文件说明： 1234&lt;!-- fingbugs.xml --&gt;&lt;Detector class="com.github.plugin.MyDetector" reports="MY_BUG" speed="fast" /&gt;&lt;BugPattern type="MY_BUG" category="CORRECTNESS" /&gt; 在src/main/resources目录下添加messages.xml文件说明： 12345678910111213141516171819&lt;!-- messages.xml --&gt;&lt;Detector class="com.github.plugin.MyDetector"&gt; &lt;Details&gt; Original detector to detect MY_BUG bug pattern. &lt;/Details&gt;&lt;/Detector&gt;&lt;BugPattern type="MY_BUG"&gt; &lt;ShortDescription&gt;Explain bug pattern shortly.&lt;/ShortDescription&gt; &lt;LongDescription&gt; Explain existing problem in code, and how developer should improve their implementation. &lt;/LongDescription&gt; &lt;Details&gt; &lt;![CDATA[ &lt;p&gt;Explain existing problem in code, and how developer should improve their implementation.&lt;/p&gt; ]]&gt; &lt;/Details&gt;&lt;/BugPattern&gt; 打jar包，参考命令行mvn打包,将target文件夹下的jar包放入spotbugs根目录下的plugin文件夹即可。]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Findbugs的安装及使用]]></title>
    <url>%2F2018%2F07%2F03%2FFindbugs%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[源码检测包括代码检查、静态结构分析、代码质量度量等。它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具自动进行。 介绍源码检测(一些源码检测工具) 源码检测包括代码检查、静态结构分析、代码质量度量等。它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具自动进行。代码检查代码检查包括代码走查、桌面检查、代码审查等，主要检查代码和设计的一致性，代码对标准的遵循、可读性，代码的逻辑表达的正确性，代码结构的合理性等方面；可以发现违背程序编写标准的问题，程序中不安全、不明确和模糊的部分，找出程序中不可移植部分、违背程序编程风格的问题，包括变量检查、命名和类型审查、程序逻辑审查、程序语法检查和程序结构检查等内容。 Findbugs介绍Findbugs是一个静态分析工具，它检查类或者JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。Findbugs自带检测器，其中有60余种Bad practice，80余种Correctness，1种 Internationalization，12种Malicious code vulnerability，27种Multithreaded correctness，23种Performance，43种Dodgy。我们还可以自己配置检查规则(做哪些检查,不做哪些检查)，也可以自己来实现独有的校验规则(用户自定义特定的bug模式需要继承它的接口,编写自己的校验类,属于高级技巧)。 安装及运行（非插件版）（后文都是基于非插件版）依赖 必须： Jdk7u（新版ant编译时会报错） 解压至/usr/local 配置环境变量vim /etc/bash.bashrc 1234export JAVA_HOME=/usr/local/jdk1.7.0_80export JRE_HOME=/usr/local/jdk1.7.0_80/jreexport PATH=$PATH:/usr/local/jdk1.7.0_80/binexport CLASSPATH=./:/usr/local/jdk1.7.0_80/lib:/usr/local/jdk1.7.0_80/jre/lib source并查看version Ant-1.9.x（https://ant.apache.org/bindownload.cgi） 解压至/usr/local 配置环境变量vim /etc/bash.bashrc 123#set Ant enviromentexport ANT_HOME=/usr/apache-ant-1.9.2export PATH=$PATH:$ANT_HOME/bin source并查看version Git 非必须： 安装findbugs 下载源码：https://sourceforge.net/projects/findbugs/files/findbugs/3.0.1/findbugs-3.0.1-source.zip/download?use_mirror=jaist&amp;download= 进入目录后运行ant build 配置环境变量vim /etc/bash.bashrc 123#set findbugshomeexport FINDBUGS_HOME=/usr/local/findbugs-3.0.1export PATH=$PATH:$FINDBUGS_HOME/bin source激活 运行findbugs输入命令findbugs直接进入gui，或者带命令行 基本原理它主要用到的技术是缺陷模式匹配和数据流分析： 缺陷模式匹配事先从代码分析经验中收集足够多的共性缺陷模式，将待分析代码与已有的共性缺陷模式进行模式匹配，从而完成软件的安全分析。这种方式的优点是简单方便，但是要求内置足够多缺陷模式，且容易产生误报。 数据流分析数据流分析也是一种软件验证技术，这种技术通过收集代码中引用到的变量信息，从而分析变量在程序中的赋值、引用以及传递等情况。对数据流进行 分析可以确定变量的定义以及在代码中被引用的情况，同时还能够检查代码数据流异常，如引用在前赋值在后、只赋值无引用等。数据流分析主要适合检验程序中的 数据域特性。 检测对象FindBugs检查.class文件，基于Bug Patterns概念，查找javabytecode(.class文件)中的潜在bug。主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等。 检测能力Findbugs自带检测器，其中有60余种Bad practice，80余种Correctness，1种 Internationalization，12种Malicious code vulnerability，27种Multithreaded correctness，23种Performance，43种Dodgy。 1) Bad practice 不佳实践：常见代码错误，用于静态代码检查时进行缺陷模式匹配(如重写equals但没重写 hashCode，或相反情况等)2) Correctness 可能导致错误的代码(如空指针引用、无限循环等)3) Internationalization 国际化相关问题（如错误的字符串转换等）4) Malicious code vulnerability 可能受到的恶意攻击（如访问权限修饰符的定义等）5) Multithreaded correctness 多线程的正确性（如多线程编程时常见的同步，线程调度问题等）6) Performance 运行时性能问题（如由变量定义，方法调用导致的代码低效问题等）7) Security 安全问题（如HTTP，SQL，DB等）8) Dodgy code 导致自身错误的代码（如未确认的强制转换、冗余的空值检查等） 使用方法FindBugs有两种使用形式，一是作为插件，放在Eclipse中使用，二是提供软件运行。而作为插件的形式比较方便简单，个人觉得使用起来比较合适。 深入理解findbugs Findbugs不是通过分析类文件的形式或结构来确定程序的意图，而是通常使用 观察者模式，检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。PMD也是一款静态代码分析工具，它是分析Java源文件。 可以下载到源代码，对源代码进行分析。 1）src/jui包是Findbugs开发UI界面使用到的包，src/junit是单元测试包，里面包含有对很多类的测试用例。etc文件下是包含的一些配置文件。 2）src/tools包下面有四个子文件夹，里面包含的是一些公用的工具类，比如打印bug描述，生成xml文件等。 3）src/antTask包下面是针对Ant的一些类。 4）最主要的就是src/java包下面的将近50个子文件夹，如下（未截完）： 该工具自带了一些检测器，于此同时，开发者可以根据自己的需求设计编写特定于应用程序的缺陷检测器。 5）有一个专门的文件夹edu.umd.cs.findbugs.detect，里面包含该工具提供的所有检测器，FindBugs 利用了 Byte Code Engineering Library，或称为 BCEL，以实现其检测器。所有字节码扫描检测器都基于 visitor 模式，FindBugs 实现了这个模式。它提供了这些方法的默认实现，在实现自定义检测器时要覆盖这些方法。我们将侧重于两个方法——visit(Code)和sawOpcode(int)。在 FindBugs 分析类时，它会在分析方法内容时调用visit(Code)方法。与此类似，FindBugs 在分析方法正文中的每一个操作码时调用sawOpcode(int)方法。 定制规则 很棒的参考： 如何编写自定义检测器以查找特定于应用程序的问题 静态代码扫描——FindBugs自定义规则入门 增加自定义findbugs规则集 编写完自定义的规则后配置两个xml文件然后使用ant重新打包生成即可 关于如何编写规则 FindBugs利用了BCEL字节码程序设计库，这个设计库专门用于分析java字节码，简明教程,其api文档 需要熟悉fingbugs检测器提供的api 规则整理中文1 中文2 原文 参考文献编写自定义检测器 提高代码质量 findBugs学习小结 FindBugs，一个不错的静态分析工具 增加自定义findbugs规则集 SpotBugs SpotBugs是Findbugs的继任者，Findbugs已经不再维护，不过SpotBugs继承了绝大部分Fingbugs的代码结构。]]></content>
      <categories>
        <category>源码检测</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法小计B3]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%A1B3%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 leetcode-5 Longest Palindromic Substringbest solution1234567891011121314151617181920212223242526272829303132class Solution&#123; public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int len = s.size(); int middle = 0; int maxl = 1; int left,right; string maxs = s.substr(0, 1); while (middle&lt;len&amp;&amp;len-middle&gt;=maxl/2) &#123; left = right = middle; while(right&lt;len-1&amp;&amp; s[right]==s[right+1]) ++right; middle = right+1; while(right&lt;len-1&amp;&amp;left&gt;0&amp;&amp;s[right+1]==s[left-1])&#123; ++right; --left; &#125; if(maxl&lt;right-left+1) &#123; maxl = right-left+1; maxs = s.substr(left,maxl); &#125; &#125; return maxs; &#125;&#125;; first commit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution&#123; public: string longestPalindrome(string s) &#123; int len = s.size(); int b = 0, e = len - 1; int maxl = 1; string maxs = s.substr(0, 1); while (len - b &gt; maxl) &#123; while (e - b+1 &gt; maxl) &#123; int l = isPalindromic(s, b, e); if (!l) &#123; --e; continue; &#125; if (l &gt; maxl) &#123; maxl = l; maxs = s.substr(b, maxl); break; &#125; --e; &#125; ++b; e = len - 1; &#125; return maxs; &#125; int isPalindromic(string s, int b, int e) &#123; int i = b, j = e; while (i &lt; j) &#123; if (s[i] != s[j]) return 0; else &#123; ++i; --j; &#125; &#125; return (e - b + 1); &#125;&#125;; leetcode-6 ZigZag Conversionbest solution1234567891011121314151617181920212223242526272829class Solution&#123; public: string convert(string s, int numRows) &#123; if (numRows &lt;= 1) return s; int len = s.size(); vector&lt;string&gt; pa(numRows, ""); int i = 0; while(i&lt;len)&#123; for(int rows = 0; rows &lt; numRows&amp;&amp;i&lt;len; rows++) &#123; pa[rows].push_back(s[i]); ++i; &#125; for (int rows = numRows-2; rows &gt; 0&amp;&amp;i&lt;len; rows--) &#123; pa[rows].push_back(s[i]); ++i; &#125; &#125; string zigzag; for (string &amp;str : pa) zigzag += str; return zigzag; &#125;&#125;; first commit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution&#123; public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; int len = s.size(); vector&lt;char&gt; pa[numRows]; int row = 0; bool jishu = 1; for (int i = 0; i &lt; len;) &#123; if (row == numRows) &#123; jishu = !jishu; row = numRows-1; &#125; if (row == -1) &#123; jishu = !jishu; row = 0; &#125; if (jishu) &#123; pa[row].push_back(s[i]); ++i; ++row; &#125; else &#123; if (row == 0 || row == numRows - 1) &#123; pa[row].push_back('#'); &#125; else &#123; pa[row].push_back(s[i]); ++i; &#125; --row; &#125; &#125; string sout; for (int i = 0; i &lt; numRows; i++) &#123; for (auto j = pa[i].begin(); j != pa[i].end(); j++) &#123; if (*j != '#') sout.push_back(*j); &#125; &#125; return sout; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAG上的动态规划]]></title>
    <url>%2F2018%2F05%2F02%2FDAG%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 矩形问题嵌套矩形问题。有n个矩形，每个矩形可以用两个整数a、b描述，表示它的长和宽。矩形X(a,b)可以嵌套在矩形Y(c, d)中，当且仅当a＜c，b＜d，或者b＜c，a＜d（相当于把矩形X旋转90°）。例如，(1, 5)可以嵌套在(6, 2)内，但不能嵌套在(3, 4)内。你的任务是选出尽量多的矩形排成一行，使得除了最后一个之外，每一个矩形都可以嵌套在下一个矩形内。如果有多解，矩形编号的字典序应尽量小。 HINT矩形之间的“可嵌套”关系是一个典型的二元关系，二元关系可以用图来建模。如果矩形X可以嵌套在矩形Y里，就从X到Y连一条有向边。这个有向图是无环的，因为一个矩形无法直接或间接地嵌套在自己内部。换句话说，它是一个DAG。这样，所要求的便是DAG上的最长路径。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 动态规划问题是逆向思考的// dp(i)表示从序号i出发的最长路径int dp(int i) &#123; int&amp; ans = d[i]; // 为了不浪费了劳动力，如果d[i]被确定过，则直接返回 if(ans &gt; 0) return ans; ans = 1; // i-&gt;j有边,表示i能走向j，d[i]则为ans和d[j]+1的最大值 for(int j = 1; j &lt;= n; j＋＋) if(G[i][j]) ans = max(ans, dp(j)＋1); // 经过上述步骤，d[i]就确定了不会再改变了 return ans;&#125;int d[n];memset(d, 0, sizeof(d));for(int i = 1; i&lt;=n; ++i)&#123; d[i] = dp(i);&#125;// 选出最大的d[max] 然后 print_ans(max)void print_ans(int i) &#123; printf("％d ", i); for(int j = 1; j &lt;= n; j++) if(G[i][j] &amp;&amp; d[i] == d[j]+1)&#123; print_ans(j); break; &#125;&#125;// 选出最大的d[max] 然后 print_ans(max)// 打出所有最长路径void print_ans(vector&lt;int&gt; vec) &#123; // printf("％d ", i); int ok = 1; for(int j = 1; j &lt;= n; j++) if(G[vec.back()][j] &amp;&amp; d[vec.back()] == d[j]+1)&#123; ok = 0; vec.push_back(j); print_ans(vec); // break; &#125; if(ok)&#123; for(auto i = vec.begin(); i!=vec.end(); ++i) cout&lt;&lt;vec[i]; &#125;&#125; 硬币问题硬币问题。有n种硬币，面值分别为V1, V2, …, Vn，每种都有无限多。给定非负整数S，可以选用多少个硬币，使得面值之和恰好为S？输出硬币数目的最小值和最大值。1≤n≤100，0≤S≤10000，1≤Vi≤S。 HINt此问题尽管看上去和嵌套矩形问题很不一样，但本题的本质也是DAG上的路径问题。将每种面值看作一个点，表示“还需要凑足的面值”，则初始状态为S，目标状态为0。若当前在状态i，每使用一个硬币j，状态便转移到i－Vj。这个模型和上一题类似，但也有一些明显的不同之处：上题并没有确定路径的起点和终点（可以把任意矩形放在第一个和最后一个），而本题的起点必须为S，终点必须为0；点固定之后“最短路”才是有意义的。在上题中，最短序列显然是空（如果不允许空，就是单个矩形，不管怎样都是平凡的），而本题的最短路却不容易确定。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 最长路int dpa(int S)&#123; // 判重是为了不浪费成果 if(vis[S]) return d[S]; vis[S] = 1; int&amp; ans = d[S]; ans = -(1&lt;&lt;30); for(int i = 1; i &lt;= n; i＋＋) if(S &gt;= V[i]) ans = max(ans, dpa(S-V[i])＋1); return ans;&#125;// 最短路int dpi(int S)&#123; // 判重是为了不浪费成果 if(vis[S]) return d[S]; vis[S] = 1; int&amp; ans = d[S]; ans = INF; if(S=0) ans = -(1&lt;&lt;30); for(int i = 1; i &lt;= n; i＋＋) if(S &gt;= V[i]) ans = min(ans, dpi(S-V[i])＋1); return ans;&#125;memset(vis, 0, sizeof(vis));// 最短和最长minv[0] = maxv[0] = 0;for(int i = 1; i &lt;= S; i＋＋)&#123; minv[i] = INF; maxv[i] = -INF;&#125;// 状态流的方向为S-&gt;0，所以外层是1-&gt;S;为了保证计算i时，i-V[j]已经被计算// 参考算法小计B2 18-5-3for(int i = 1; i &lt;= S; i＋＋) for(int j = 1; j &lt;= n; j＋＋) if(i &gt;= V[j])&#123; minv[i] = min(minv[i], minv[i-V[j]] + 1); maxv[i] = max(maxv[i], maxv[i-V[j]] + 1); &#125;printf("%d %d\n", minv[S], maxv[S]);void print_ans(int* d, int S)&#123; for(int i = 1; i &lt;= n; i++) if(S&gt;=V[i] &amp;&amp; d[S]==d[S-V[i]]+1)&#123; printf("%d ", i); print_ans(d, S-V[i]); break; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量化短文本及相似度的计算]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%90%91%E9%87%8F%E5%8C%96%E7%9F%AD%E6%96%87%E6%9C%AC%E5%8F%8A%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[两篇中文文本，如何计算相似度？相似度是数学上的概念，自然语言肯定无法完成，所有要把文本转化为向量。转化为向量之后便可以使用欧式距离、余弦距离等计算相似度，或者通过Softmax网络（或基于Hierarchical Softmax的模型或基于Negative Sampling的模型）计算属类概率。 【转】 python文本相似度计算 步骤 分词、去停用词 词袋模型向量化文本 TF-IDF模型向量化文本 LSI模型向量化文本 计算相似度 理论如何向量化： 词袋模型最简单的表示方法是词袋模型。把一篇文本想象成一个个词构成的，所有词放入一个袋子里，没有先后顺序、没有语义。例如：John likes to watch movies. Mary likes too.John also likes to watch football games.这两个句子，可以构建出一个词典，key为上文出现过的词，value为这个词的索引序号{“John”: 1, “likes”: 2,”to”: 3, “watch”: 4, “movies”: 5,”also”: 6, “football”: 7, “games”: 8,”Mary”: 9, “too”: 10}那么，上面两个句子用词袋模型表示成向量就是：[1, 2, 1, 1, 1, 0, 0, 0, 1, 1][1, 1,1, 1, 0, 1, 1, 1, 0, 0]相对于英文，中文更复杂一些，涉及到分词。准确地分词是所有中文文本分析的基础，本文使用结巴分词，完全开源而且分词准确率相对有保障。 TF-IDF模型词袋模型简单易懂，但是存在问题。中文文本里最常见的词是“的”、“是”、“有”这样的没有实际含义的词。一篇关于足球的中文文本，“的”出现的数量肯定多于“足球”。所以，要对文本中出现的词赋予权重。一个词的权重由TF * IDF 表示，其中TF表示词频，即一个词在这篇文本中出现的频率；IDF表示逆文档频率，即一个词在所有文本中出现的频率倒数。因此，一个词在某文本中出现的越多，在其他文本中出现的越少，则这个词能很好地反映这篇文本的内容，权重就越大。回过头看词袋模型，只考虑了文本的词频，而TF-IDF模型则包含了词的权重，更加准确。文本向量与词袋模型中的维数相同，只是每个词的对应分量值换成了该词的TF-IDF值。 LSI模型TF-IDF模型足够胜任普通的文本分析任务，用TF-IDF模型计算文本相似度已经比较靠谱了，但是细究的话还存在不足之处。实际的中文文本，用TF-IDF表示的向量维数可能是几百、几千，不易分析计算。此外，一些文本的主题或者说中心思想，并不能很好地通过文本中的词来表示，能真正概括这篇文本内容的词可能没有直接出现在文本中。因此，这里引入了Latent Semantic Indexing（LSI）从文本潜在的主题来进行分析。LSI是概率主题模型的一种，另一种常见的是LDA，核心思想是：每篇文本中有多个概率分布不同的主题；每个主题中都包含所有已知词，但是这些词在不同主题中的概率分布不同。LSI通过奇异值分解的方法计算出文本中各个主题的概率分布，严格的数学证明需要看相关论文。假设有5个主题，那么通过LSI模型，文本向量就可以降到5维，每个分量表示对应主题的权重。 demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import warningswarnings.filterwarnings(action='ignore',category=UserWarning,module='gensim')import jieba.posseg as psegimport codecsfrom gensim import corpora, models, similaritiesfrom gensim.models import word2vecimport os# 遍历获取所有样本path = r'resource\sougou_data_all'filenames = []for dirpath, dirnames, filenames in os.walk(path): for file in filenames: fullpath = os.path.join(dirpath,file) filenames.append(fullpath) # print(fullpath)# 构建停用词表stop_words = "resource/stop_words.txt"stopwords = codecs.open(stop_words,'r',encoding='utf8').readlines()stopwords = [ w.strip() for w in stopwords ]# 结巴分词后的停用词性 [标点符号、连词、助词、副词、介词、时语素、‘的’、数词、方位词、代词]stop_flag = ['x', 'c', 'u','d', 'p', 't', 'uj', 'm', 'f', 'r']# 对一篇文章分词、去停用词def tokenization(filename): result = [] with open(filename, 'r') as f: text = f.read() words = pseg.cut(text) for word, flag in words: if flag not in stop_flag and word not in stopwords: result.append(word) return result# 建立词袋模型-begincorpus = []for each in filenames: # print(tokenization(each)) corpus.append(tokenization(each))# print (corpus[0])dictionary = corpora.Dictionary(corpus)# print(dictionary)doc_vectors = [dictionary.doc2bow(text) for text in corpus]# print (len(doc_vectors))# print (doc_vectors)# 建立词袋模型-end# 建立TF-IDF模型-begintfidf = models.TfidfModel(doc_vectors)tfidf_vectors = tfidf[doc_vectors]# print (len(tfidf_vectors))# print (len(tfidf_vectors[0]))# 建立TF-IDF模型-end# 测试testfile = 'resource/sougou_data_all/财经/999.txt'query = tokenization(testfile)query_bow = dictionary.doc2bow(query)# 输出测试样本与训练样本的相似度index = similarities.MatrixSimilarity(tfidf_vectors)sims = index[query_bow]print (list(enumerate(sims)))# 构建LSI模型，设置主题数为9lsi = models.LsiModel(tfidf_vectors, id2word=dictionary, num_topics=9)lsi_vector = lsi[tfidf_vectors]for vec in lsi_vector: print(vec)# 维度相等# 输出测试样本与训练样本的相似度query_lsi = lsi[query_bow]index = similarities.MatrixSimilarity(lsi_vector)sims = index[query_lsi]print (list(enumerate(sims)))]]></content>
      <categories>
        <category>机器学习与算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唯一的雪花（Unique snowflakes, UVa 11572）]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1%EF%BC%88Unique-snowflakes-UVa-11572%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目输入一个长度为n（n≤106）的序列A，找到一个尽量长的连续子序列AL～AR，使得该序列中没有相同的元素。 思路1HINT假设序列元素从0开始编号，所求连续子序列的左端点为L，右端点为R。首先考虑起点L=0的情况。可以从R=0开始不断增加R，相当于把所求序列的右端点往右延伸。当无法延伸（即A[R+1]在子序列A[L～R]中出现过）时，只需增大L，并且继续延伸R。既然当前的A[L～R]是可行解，L增大之后必然还是可行解，所以不必减少R，继续增大即可。不难发现这个算法是正确的，不过真正有意思的是算法的时间复杂度。暂时先不考虑“判断是否可以延伸”这个部分，每次要么把R加1，要么把L加1，而L和R最多从0增加到n-1，所以指针增加的次数是O(n)的。最后考虑“判断是否可以延伸”这个部分。比较容易想到的方法是用一个STL的set，保存A[L～R]中元素的集合，当R增大时判断A[R+1]是否在set中出现，而R加1时把A[R+1]插入到set中，L+1时把A[L]从set中删除。因为set的插入删除和查找都是O(logn)的，所以这个算法的时间复杂度为O(nlogn)。代码如下： 代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000000 + 5;int A[maxn];int main( ) &#123; int T, n; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;A[i]); set&lt;int&gt; s; int L=0, R=0, ans = 0; while(R&lt;n)&#123; while(R&lt;n&amp;&amp;!s.count(A[R]))&#123; s.insert(A[R]) ++R; &#125; ans = max(ans, R - L); ++L; s.erase(A[L]) &#125; cout&lt;&lt;ans; &#125;&#125; 思路2HINT另一个方法是用一个map求出last[i]，即下标i的“上一个相同元素的下标”。例如，输入序列为3 2 4 1 3 2 3，当前区间是[1,3]（即元素2, 4, 1），是否可以延伸呢？下一个数是A[5]=3，它的“上一个相同位置”是下标0（A[0]=3），不在区间中，因此可以延伸。map的所有操作都是O(logn)的，但后面所有操作的时间复杂度均为O(1)，总时间复杂度也是O(nlogn)。 代码1234567891011121314151617181920212223242526272829#include&lt;map&gt;using namespace std;const int maxn = 1000000 + 5;int A[maxn], last[maxn];map&lt;int, int&gt; cur;int main( ) &#123; int T, n; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); cur.clear( ); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;A[i]); if(!cur.count(A[i])) last[i] = -1; else last[i] = cur[A[i]]; cur[A[i]] = i; &#125; int L = 0, R = 0, ans = 0; while(R&lt;n)&#123; while(R&lt;n&amp;&amp;last[R]&lt;L) ++R; ans = max(ans, R - L); ++L; // L = last[R]+1; &#125; cout&lt;&lt;ans; &#125;&#125; 12345678910111213141516int Solution::lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); // map&lt;char, int&gt; mp; int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; //if(mp.count(s[i])) // if(mp[s[i]] &gt; start) // start = mp[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器逆向分析------firmware-mod-kit工具安装和使用说明]]></title>
    <url>%2F2018%2F04%2F19%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-firmware-mod-kit%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[固件逆向的工具，firmware-mod-kit是集大成者 转自 路由器逆向分析——firmware-mod-kit工具安装和使用说明 官方文档 论坛 firmware-mod-kit工具的安装（Ubuntu）firmware-mod-kit工具的功能和binwalk工具的类似，其实firmware-mod-kit工具在功能上有调用binwalk工具提供的功能以及其他的固件解包工具的整合。下载firmware-mod-kit工具的源码进入到src目录下就能够看到firmware-mod-kit工具整合了那些固件提取和文件系统解压的工具。firmware-mod-kit工具的功能有固件文件的解包和打包、固件提取文件系统的解压和压缩、DD-WRT Web Pages的修改等，在每个整合的固件分析工具的源码文件夹里都有相关的使用说明。 安装依赖1$ sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic 正式安装1234567git clone https://github.com/mirror/firmware-mod-kit.git# 进入源码目录cd firmware-mod-kit/src# 执行configure文件生成Makefile文件然后make编译生成可执行文件./configure &amp;&amp; make 使用解包固件提取内核和文件系统1$ ./extract-firmware.sh firmware.bin 重打包解包的内核和文件系统重建固件文件1$ ./build-firmware.sh [-nopad] [-min] 详见文档 附binwalk的使用方法 binwalk的提取与分析固件扫描命令：binwalk firmware.bin —–&gt; 通过扫描能够智能地发现目标文件中包含的所有可识别的文件类型。 提取文件命令：binwalk -e firmware.bin ——&gt; 选项“-e”和“–extract”用于按照定义的配置文件中的提取方法从固件中提取探测到的文件系统。 命令：binwalk -Me firmware.bin —–&gt; 选项“-M”和“–matryoshka”用于根据magic签名扫描结果进行递归提取，仅对”-e”和“–dd”选项有效。 命令：binwalk -Me -d 5 firmware.bin —-&gt; 选项“-d”和“–depth=“用于限制递归提取深度，默认深度为8，仅当“-M”选项存在时有效。 显示完整的扫描结果命令：binwalk -I firmware.bin ——&gt; 选项”-I”和“–invalid”用于显示扫描的所有结果（即使是扫描过程中被定义为“invalid“的项）。 当我们认为binwalk错把有效的文件当成无效文件时，可以通过该选项来检查。 指令系统分析选项“A”和“–opcodes”用于扫描指定文件中通用CPU架构的可执行代码。 由于某些操作码签名比较短，所以比较容易造成误判。如果我们需要确定一个可执行文件的CPU架构，可以使用该命令。 命令：命令：binwalk -A 70|more 使用Binwalk扫描从firmware.bin中提取的文件的文件“70”中的可执行代码，在该文件中可以发现CPU的架构（大端或者小端也会给出）。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>固件逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法小计B2]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%A1B2%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 2018-04-16P294 输出所有排列HINT递归调用 代码1234567891011121314151617181920212223242526272829303132333435// 字典序输出1-n的全排列void print_permutation(int n, int* A, int cur) &#123; if(cur == n) &#123; //递归边界 for(int i = 0; i &lt; n; i++) printf("%d ", A[i]); printf("\n"); &#125; else for(int i = 1; i &lt;= n; i++) &#123; //尝试在A[cur]中填各种整数i int ok = 1; for(int j = 0; j &lt; cur; j++) if(A[j] == i) ok = 0; //如果i已经在A[0]~A[cur-1]出现过，则不能再选 if(ok) &#123; A[cur] = i; print_permutation(n, A, cur+1); //递归调用 &#125; &#125;&#125;// 输出集合P的全排列void print_permutation(int n, int* A, int cur, int* P) &#123; if(cur == n) &#123; //递归边界 for(int i = 0; i &lt; n; i++) printf("%d ", A[i]); printf("\n"); &#125; else for(int i = 1; i &lt;= n; i++) &#123; //尝试在A[cur]中填P[i] int c1=0, c2=0; for(int k = 0; k &lt; cur; ++k) if(A[k] == P[i]) ++c1; for(int k = 0; k &lt; n; ++k) if(P[k] == P[i]) ++c2; if(c1&lt;c2) &#123; A[cur] = P[i]; print_permutation(n, A, cur+1); //递归调用 &#125; &#125;&#125; 2018-04-18P298 子集生成HINT增量构造法、位向量法、二进制法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 增量构造法,用到了定序的技巧：规定集合A中所有元素的编号从小到大排列，就不会把集合&#123;1, 2&#125;按照&#123;1, 2&#125;和&#123;2, 1&#125;输出两次了。 * @param &#123;[type]&#125; int n 集合为0~n-1 * @param &#123;[type]&#125; int* A 存放子集，待打印 * @param &#123;[type]&#125; int cur 当前元素 */void print_subset1(int n, int* A, int cur) &#123; for(int i = 0; i &lt; cur; i++) printf("%d ", A[i]); //打印当前集合 printf("\n"); int s = cur ? A[cur-1]+1 : 0; //确定当前元素的最小可能值 for(int i = s; i &lt; n; i++) &#123; A[cur] = i; print_subset(n, A, cur+1); //递归构造子集 &#125;&#125;/** * 位向量法 * @param &#123;[type]&#125; int n 集合为0~n-1 * @param &#123;[type]&#125; int* B 存放子集，待打印 * @param &#123;[type]&#125; int cur 当前元素 */void print_subset2(int n, int* B, int cur) &#123; if(cur == n) &#123; for(int i = 0; i &lt; cur; i++) if(B[i]) printf("%d ", i); //打印当前集合 printf("\n"); return; &#125; B[cur] = 1; //选第cur个元素 print_subset(n, B, cur+1); B[cur] = 0; //不选第cur个元素 print_subset(n, B, cur+1);&#125;/** * 二进制法 * @param &#123;[type]&#125; int n 集合为0~n-1 * @param &#123;[type]&#125; int s 当前二进制数 */void print_subset3(int n, int s) &#123; //打印&#123;0, 1, 2,..., n-1&#125;的子集S for(int i = 0; i &lt; n; i++) if(s&amp;(1&lt;&lt;i)) printf("%d ", i); //这里利用了C语言"非0值都为真"的规定 printf("\n");&#125;int main()&#123; int n; cin&gt;&gt;n; int a[n]; print_subset1(n, a, 0); cout&lt;&lt;endl; print_subset2(n, a, 0); cout&lt;&lt;endl; for(int i = 0; i &lt; (1&lt;&lt;n); i++) //枚举各子集所对应的编码0, 1, 2,..., 2n-1 print_subset3(n, i);&#125; 2018-04-19八皇后问题HINT使用book数组判重 代码123456789101112131415161718192021222324252627const int maxn = 100;int book[3][maxn] = &#123;0&#125;;int C[maxn];int tot = 0;int n;void search(int cur) &#123; if(cur == n) tot++; else&#123; for(int i = 0; i&lt;n; ++i)&#123; if(!book[0][i]&amp;&amp;!book[1][cur+i]&amp;&amp;!book[2][cur-i+n])&#123; C[cur] = i; book[0][i] = book[1][cur+i] = book[2][cur-i+n] = 1; search(cur+1); book[0][i] = book[1][cur+i] = book[2][cur-i+n] = 0; &#125; &#125; &#125; return;&#125;int main&#123; cin&gt;&gt;n; search(0); cout&lt;&lt;"一共有"&lt;&lt;tot&lt;&lt;"种放置方法"&lt;&lt;endl; return 0;&#125; P370 和为0的4个值HINThash降低复杂度 代码12345678910111213141516171819202122232425262728293031323334int main()&#123; int n; cin&gt;&gt;n; vector&lt;vector&lt;int&gt;&gt; vec(4,vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; cin&gt;&gt;vec[i][j]; &#125; &#125; unordered_map&lt;int, int&gt; mp; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; int aplusb = vec[0][k] + vec[1][i]; if (!mp.count(aplusb)) mp[aplusb] = 1; else mp[aplusb]++; &#125; &#125; int count = 0; for (int l = 0; l &lt; n; ++l) &#123; for (int i = 0; i &lt; n; ++i) &#123; int cplusd = -(vec[2][l] + vec[3][i]); if (mp.count(cplusd)) count+=mp[cplusd]; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl;&#125; P372 Gergovia的酒交易HINT扫描法 代码12345678910111213int main( ) &#123; int n; while(cin &gt;&gt; n &amp;&amp; n) &#123; long long ans = 0, a, last = 0; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; ans += abs(last); last += a; &#125; cout &lt;&lt; ans &lt;&lt; "\n"; &#125; return 0;&#125; 2018-04-21两个有序数组求中位数代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 双指针int main()&#123; int m,n; cin&gt;&gt;m&gt;&gt;n; int a[m], b[n]; for (int i = 0; i &lt; m; ++i) &#123; cin&gt;&gt;a[i]; &#125; for (int j = 0; j &lt; n; ++j) &#123; cin&gt;&gt;b[j]; &#125; int i = 0,j = 0; int length = m+n; int count = 0; if((length&amp;1) == 1) &#123; int final = 0; while (i != m &amp;&amp; j != n &amp;&amp; count!= length/2+1) &#123; if (a[i] &gt; b[j]) &#123; final = b[j]; ++j; &#125; else &#123; final = a[i]; ++i; &#125; ++count; &#125; if (count-1 == length/2)&#123; cout&lt;&lt;final; &#125;else &#123; if (i == m) &#123; if (j == n) &#123; cout &lt;&lt; "kong"; &#125; else &#123; cout &lt;&lt; b[length / 2 - m]; &#125; &#125; else if (j == n) &#123; cout &lt;&lt; a[length / 2 - n]; &#125; &#125; &#125;else &#123; int second = 0; int first = 0; int count = 0; while (i != m &amp;&amp; j != n &amp;&amp; count- 1 != length / 2) &#123; ++count; if (a[i] &gt; b[j]) &#123; if(count == length/2)&#123; first = b[j]; &#125; second = b[j]; ++j; &#125; else &#123; if(count == length/2) &#123; first = a[i]; &#125; second = a[i]; ++i; &#125; &#125; if(count-1 == length/2) &#123; cout &lt;&lt; (first + second) / 2.0; &#125;else &#123; if (i == m) &#123; if (j == n) &#123; cout &lt;&lt; "kong"; &#125; else &#123; if (first)&#123; cout&lt;&lt;(first+b[length/2 -m])/2.0; &#125; else &#123; cout &lt;&lt; (b[length / 2 - m - 1] + b[length / 2 - m]) / 2.0; &#125; &#125; &#125; else if (j == n) &#123; if (first) &#123; cout &lt;&lt; (a[length / 2 - n] + first) / 2.0; &#125; else &#123; cout &lt;&lt; (a[length / 2 - n - 1] + a[length / 2 - n]) / 2.0; &#125; &#125; &#125; &#125; return 0;&#125; 2018-04-23P381 全部相加HINThuffman编码的建立过程 代码1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int main() &#123; int n, x; while(scanf("%d", &amp;n) == 1 &amp;&amp; n) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;x); q.push(x); &#125; int ans = 0; for(int i = 0; i &lt; n-1; i++) &#123; int a = q.top( ); q.pop( ); int b = q.top( ); q.pop( ); ans += a+b; q.push(a+b); &#125; printf("%d\n", ans); &#125; return 0;&#125; 回忆：huffman编码12345678910111213141516171819202122232425262728293031323334353637383940void Huffman::HuffmanTree(element huffTree[ ], int w[ ], int n )&#123; for (i=0; i&lt;2*n-1; i++) &#123; huffTree [i].parent= -1; huffTree [i].lchild= -1; huffTree [i].rchild= -1; &#125; for (i=0; i&lt;n; i++)//0-n-1存放叶子节点 huffTree [i].weight=w[i]; for (k=n; k&lt;2*n-1; k++) &#123; int i1,i2; SelectMin( i1, i2，0，k-1); huffTree[i1].parent=k; huffTree[i2].parent=k; huffTree[k].weight=huffTree[i1].weight+huffTree[i2].weight; huffTree[k].lchild=i1; huffTree[k].rchild=i2; &#125;&#125;// 从s到e中找到权值未被使用的两个最小值void Huffman::SelectMin(int &amp;x, int &amp;y, int s, int e )&#123; int i; for ( i=s; i&lt;=e;i++) if (HTree[i].parent == -1) &#123; x =y= i; break; //找出第一个有效权值x，并令y=x &#125; for ( ; i&lt;e;i++) if (HTree[i].parent == -1) //该权值未使用过 &#123; if ( HTree[i].weight&lt; HTree [x].weight) &#123; y = x; x = i; //迭代，依次找出前两个最小值 &#125; else if ((x==y) || (HTree[i].weight&lt; HTree [y].weight) ) y = i; //找出第2个有效权值 y &#125;&#125; P406 记忆化搜索与递推HINT避免递归搜索时重复执行操作 代码1234567//思路memset(d,－1,sizeof(d));int solve(int i, int j)&#123; if(d[i][j] ＞= 0) return d[i][j]; return d[i][j] = a[i][j] ＋ (i == n ? 0 : max(solve(i＋1,j),solve(i＋1,j＋1)));&#125; 2018-04-24P265 给任务排序HINTdfs判断是否不存在环 代码1234567891011121314151617181920212223242526int c[maxn];int topo[maxn], t;bool dfs(int u)&#123; c[u] = -1;//正在访问 // 判断是否存在环，如果有则返回false，如果出循环都没有则返回true for(int i = 0; i&lt;n; ++i)&#123; if(G[u][i])&#123; if(c[i] == -1) return false; else if(!c[i]&amp;&amp;!dfs(i)) return false; &#125; &#125; c[u] = 1;topo[--t] = u; return true;&#125;bool toposort( )&#123; t = n; memset(c, 0, sizeof(c)); for(int u = 0; u &lt; n; u++) if(!c[u]) if(!dfs(u)) return false; return true;&#125; 2018-04-25P266 欧拉回路HINT设置标记 代码123456789void elur(int cur)&#123; for(int i = 0; i&lt;n; ++i)&#123; if(G[cur][i]&amp;&amp;!book[cur][i])&#123; book[cur][i] = book[i][cur] = 1; elur(i); cout&lt;&lt;cur&lt;&lt;" "&lt;&lt;i; &#125; &#125;&#125; 2018-05-03P416 城市里的间谍HINTDAG动态规划问题,时间是单向的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int main()&#123; int n;cin&gt;&gt;n; int T;cin&gt;&gt;T; int t[n]; for(int i = 1; i&lt;n; ++i) cin&gt;&gt;t[i]; int M1;cin&gt;&gt;M1; int d1[M1+1]; int max1 = 0; for (int i = 1; i&lt;M1+1; ++i)&#123; cin&gt;&gt;d1[i]; if(d1[i]&gt;max1) max1 = d1[i]; &#125; int M2;cin&gt;&gt;M2; int d2[M1+1]; int max2 = 0; for (int i = 1; i&lt;M2+1; ++i)&#123; cin&gt;&gt;d2[i]; if(d2[i]&gt;max2) max2 = d2[i]; &#125; for(int i = max1; i&gt;=0; --i)&#123; has_train[i][1][0] = 1; &#125; for(int i = max2; i&gt;=0; --i)&#123; has_train[i][n][1] = 1; &#125; for(int i = 1; i&lt;M1+1; ++i)&#123; int tt = d1[i]; for(int j = 2; j &lt;= n; ++j)&#123; tt += t[j-1]; has_train[tt][j][0] = 1; &#125; &#125; for(int i = 1; i&lt;M2+1; ++i)&#123; int tt = d2[i]; for(int j = n-1 ; j &gt;= 1; ++j)&#123; tt += t[j]; has_train[tt][j][1] = 1; &#125; &#125; for(int i = 1; i &lt;= n-1; i++) dp[T][i] = INF; dp[T][n] = 0; // 参考DAG专题，这里的时间流逝是1-&gt;T，所以外层是从T-1到0（是相反的）； for(int i = T-1; i &gt;= 0; i--) for(int j = 1; j &gt;= n; j++) &#123; dp[i][j] = dp[i+1][j] + 1; //等待一个单位 if(j &lt; n &amp;&amp; has_train[i][j][0] &amp;&amp; i+t[j] ＜= T) dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); //右 if(j &gt; 1 &amp;&amp; has_train[i][j][1] &amp;&amp; i+t[j-1] ＜= T) dp[i][j] = min(dp[i][j], dp[i+t[j-1]][j-1]); //左 &#125; //输出 cout &lt;&lt; "Case Number " &lt;&lt; ++kase &lt;&lt; ": "; if(dp[0][1] &gt;= INF) cout &lt;&lt; "impossible\n"; else cout &lt;&lt; dp[0][1] &lt;&lt; "\n";&#125; 2018-05-04P422背包问题HINT固定起点的DAG最长路径问题，引入层数 代码1234567891011121314151617181920212223242526272829303132333435// d(i, j)表示“把第i, i＋ 1 , i＋2,…, n个物品装到容量为j的背包中的最大总重量”。// 边界是i＞n时d(i,j)=0，j＜0时为负无穷for(int i = n; i &gt;= 1; i--) for(int j = 0; j &lt;= C; j++)&#123; d[i][j] = (i==n ? 0 : d[i+1][j]);// 不放v[i]，直接进下一层 if(j &gt;= V[i]) d[i][j] max(d[i][j],d[i+1][j-V[i]]+W[i]); &#125;cout&lt;&lt;d[1][C];// f[i][j]表示第i层(第i次装载动作，可选择是否装载v[i])总体积为j时背包的最大重量// i=0时为0，j＜0时为负无穷for(int i = 1; i &lt;= n; i＋＋) for(int j = 0; j &lt;= C; j＋＋)&#123; f[i][j] = (i==1 ? 0 : f[i-1][j]);// 在第i层不装载v[i]，直接进入前一层 if(j &gt;= V[i]) f[i][j] = max(f[i][j], f[i-1][j-V[i]]+W[i]); &#125;cout&lt;&lt;f[n][C];// 与f一样，不需要记录v[i]了for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;V, &amp;W); for(int j = 0; j &lt;= C; j++)&#123; f[i][j] = (i==1 ? 0 : f[i-1][j]); if(j &gt;= V) f[i][j] = max(f[i][j],f[i-1][j-V]+W); &#125;&#125;memset(f, 0, sizeof(f));for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;V, &amp;W); for(int j = C; j &gt;= 0; j——) if(j &gt;= V) f[j] = max(f[j], = f[j－V]+W);&#125; P420 单向TSPHINT多阶段决策的最优化问题 代码12345678910111213141516171819202122232425262728int main()&#123; const int INF = 1000; int ans = INF, first = 0; for(int j = n-1; j &gt;= 0; j--) &#123; //逆推 for(int i = 0; i &lt; m; i++) &#123; if(j == n-1) d[i][j] = a[i][j]; //边界 else &#123; int rows[3] = &#123;i, i-1, i+1&#125;; if(i == 0) rows[1] = m-1; //第0行"上面"是第m－1行 if(i == m-1) rows[2] = 0; //第m－1行"下面"是第0行 sort(rows, rows+3); //重新排序，以便找到字典序最小的 d[i][j] = INF; for(int k = 0; k &lt; 3; k++) &#123; int v = d[rows[k]][j+1] + a[i][j]; if(v &lt; d[i][j]) &#123; d[i][j] = v; next[i][j] = rows[k]; &#125; &#125; &#125; if(j == 0 &amp;&amp; d[i][j] &lt; ans) &#123; ans = d[i][j]; first = i; &#125; &#125; &#125; printf("％d", first+1); //输出第1列 for(int i = next[first][0], j = 1; j &lt; n; i = next[i][j], j++) printf(" %d", i+1); //输出其他列 printf("\n%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代加深搜索-埃及分数问题]]></title>
    <url>%2F2018%2F04%2F17%2F%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目HINT代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const int maxn = 1000int ans[maxn], v[maxn];//满足1/c≤a/b的最小cint get_first(int a, int b)&#123; for(int i = 1; ;++i)&#123; if(1/i &lt;= a/b) return i; &#125;&#125;//如果当前解v比目前最优解ans更优，更新ansbool better(int d) &#123; for(int i = d; i &gt;= 0; i--) if(v[i] != ans[i]) &#123; return ans[i] == -1 || v[i] &lt; ans[i]; &#125; return false;&#125;//当前深度为d，分母不能小于from，分数之和恰好为aa/bb//往一个方向收敛则无需判重bool dfs(int d, int from, LL aa, LL bb) &#123; if(d == maxd) &#123; if(bb % aa) return false; //aa/bb必须是埃及分数 v[d] = bb/aa; if(better(d)) memcpy(ans, v, sizeof(LL) * (d+1)); return true; &#125; bool ok = false; from = max(from, get_first(aa, bb)); //枚举的起点 for(int i = from; ; i++) &#123; //剪枝：如果剩下的maxd+1-d个分数全部都是1/i，加起来仍然不超过aa/bb，则无解 if(bb * (maxd+1-d) &lt;= i * aa) break; v[d] = i; //计算aa/bb - 1/i，设结果为a2/b2 LL b2 = bb*i; LL a2 = aa*i - bb; LL g = gcd(a2, b2); //以便约分 if(dfs(d+1, i+1, a2/g, b2/g)) ok = true; &#125; return ok;&#125;int main()&#123; int maxd; int a,b; cin&gt;&gt;a&gt;&gt;b; int ok = 0; for(maxd = 1; ; maxd++) &#123; memset(ans, -1, sizeof(ans)); if(dfs(0, get_first(a, b), a, b)) &#123; ok = 1; break; &#125; &#125; for(int i = 0; i&lt;maxn; ++i)&#123; if(v[i])&#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125;else break; &#125; return 0;&#125; 总结]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒水问题fill-UVa 10603]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98fill-UVa-10603%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目 测试输入1 1 12 15 7 测试输出14 7 HINTbfs+prioqueue,队列扩展优先总倒水量小的 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int maxn = 200 + 5;struct WaterNode&#123; int v[3]; int dist; WaterNode ():dist(0)&#123;&#125; bool operator &lt; (const WaterNode&amp; rhs) const&#123; return dist &gt; rhs.dist; &#125;&#125;;int ans[maxn];// ans[d]表示得到d升水的最小水量int cap[3];// 每杯水的容量int book[maxn][maxn];void updateAns(const WaterNode&amp; n)&#123; for (int i = 0; i &lt; 3; ++i) &#123; if (ans[n.v[i]] &lt; 0 || ans[n.v[i]] &gt; n.dist) ans[n.v[i]] = n.dist; &#125;&#125;void bfs(int a, int b, int c, int d)&#123; cap[0] = a;cap[1] = b;cap[2] = c; memset(book, 0, sizeof(book)); memset(ans, -1, sizeof(ans)); priority_queue&lt;WaterNode&gt; waterQueue; WaterNode start; start.v[0] = 0; start.v[1] = 0; start.v[2] = c; waterQueue.push(start); book[0][0] = 1; while(!waterQueue.empty())&#123; WaterNode fro = waterQueue.top(); // 更新ans updateAns(fro); if(ans[d] &gt;= 0) break; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; if (i != j)&#123; // i往j倒水 if (fro.v[i] == 0 || fro.v[j] == cap[j]) continue; WaterNode nextNode; memcpy(nextNode.v, fro.v, sizeof(fro.v)); int amount = min(cap[j], fro.v[i]+fro.v[j]) - fro.v[j]; nextNode.v[i] -= amount; nextNode.v[j] += amount; nextNode.dist = fro.dist + amount; if (!book[nextNode.v[i]][nextNode.v[j]])&#123; book[nextNode.v[i]][nextNode.v[j]] = 1; waterQueue.push(nextNode); &#125; &#125; &#125; &#125; waterQueue.pop(); &#125; while (d&gt;=0)&#123; if(ans[d] &gt;= 0) &#123; printf("%d %d\n", ans[d], d); return; &#125; d--; &#125;&#125;int main( ) &#123; int T, a, b, c, d; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); bfs(a, b, c, d); &#125; return 0;&#125; 总结bfs求最短路径]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八数码问题]]></title>
    <url>%2F2018%2F04%2F14%2F%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目编号为1～8的8个正方形滑块被摆成3行3列（有一个格子留空），如图7-14所示。每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原来的位置就成为了新的空格。给定初始局面和目标局面（用0表示空格），你的任务是计算出最少的移动步数。如果无法到达目标局面，则输出-1。 样例输入2 6 4 1 3 7 0 5 8 8 1 5 7 3 6 4 0 2 样例输出31 HINT采用BFS求解，每次保存整体状态而非坐标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169typedef int State[9]; //定义"状态"类型const int maxstate = 1000000;State st[maxstate], goal; //状态数组。所有状态都保存在这里int dist[maxstate]; //距离数组//如果需要打印方案，可以在这里加一个"父亲编号"数组 int fa[maxstate]const int dx[ ] = &#123;-1, 1, 0, 0&#125;;const int dy[ ] = &#123;0, 0, -1, 1&#125;;//hash表存放状态，因为0-8的排列最多为9!=362880个const int hashsize = 1000003;int head[hashsize], next1[maxstate];void init_lookup_table( ) &#123; memset(head, 0, sizeof(head)); &#125;int hash1(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把9个数字组合成9位数 return v % hashsize; //确保hash函数值是不超过hash表的大小的非负整数&#125;int try_to_insert(int s)&#123; int h = hash1(st[s]); int u = head[h]; //从表头开始查找链表 while(u)&#123; if(memcmp(st[u],st[s], sizeof(st[s]))==0) return 0; //找到了，插入失败，book=1 u = next1[u]; //顺着链表继续找 &#125; next1[s] = head[h]; //插入到链表中 head[h] = s; return 1;//book=0&#125;//BFS，返回目标状态在st数组下标int bfs( ) &#123; init_lookup_table( ); //初始化查找表,用于去重 int front = 1, rear = 2; //不使用下标0，因为0被看作"不存在" while(front&lt; rear) &#123; State&amp; s = st[front]; if(memcmp(goal, s, sizeof(s)) == 0) return front;//找到目标状态，成功返回 int z; for(z = 0; z &lt; 9; z++) if(!s[z]) break; //找"0"的位置 int x = z/3, y = z%3; //获取行列编号（0~2） for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if(newx &gt;= 0 &amp;&amp; newx &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3)&#123; //如果移动合法 State&amp; t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); //扩展新结点 t[newz] = s[z]; t[z] = s[newz]; dist[rear] = dist[front] + 1; //更新新结点的距离值 if(try_to_insert(rear)) rear++; //如果成功插入查找表，修改队尾指针 &#125; &#125; front++; //扩展完毕后再修改队首指针 &#125; return 0; //失败&#125;int main( )&#123; for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;st[1][i]); //起始状态 for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;goal[i]); //目标状态 int ans = bfs( ); //返回目标状态的下标 if(ans &gt; 0) printf("%d\n", dist[ans]); else printf("-1\n"); return 0;&#125;//封装typedef int State[9]; //定义"状态"类型const int maxstate = 1000000;struct StateNode&#123; StateNode():dist(0)&#123;&#125; State stat; int dist;&#125;;State goal; //状态数组。所有状态都保存在这里//如果需要打印方案，可以在这里加一个"父亲编号"数组 int fa[maxstate]const int dx[ ] = &#123;-1, 1, 0, 0&#125;;const int dy[ ] = &#123;0, 0, -1, 1&#125;;//hash表存放状态，因为0-8的排列最多为9!=362880个const int hashsize = 1000003;struct HashNode&#123; HashNode():next(0)&#123;&#125; State stat; HashNode* next;&#125;;HashNode* head[hashsize];void init_lookup_table( ) &#123; memset(head, 0, sizeof(head)); &#125;int hash1(State s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把9个数字组合成9位数 return v % hashsize; //确保hash函数值是不超过hash表的大小的非负整数&#125;int try_to_insert(StateNode s)&#123; int h = hash1(s.stat); HashNode* u = head[h]; //从表头开始查找链表 while(u)&#123; if(memcmp(u-&gt;stat,s.stat, sizeof(s.stat))==0) return 0; //找到了，插入失败，book=1 u = u-&gt;next; //顺着链表继续找 &#125; HashNode* n = new HashNode(); memcpy(&amp;n-&gt;stat, &amp;s.stat, sizeof(s.stat)); n-&gt;next = head[h]; head[h] = n; return 1;//book=0&#125;void deleteHash(HashNode* h[])&#123; for(int i = 0; i &lt; hashsize; ++i)&#123; if(!h[i]) continue; HashNode* cur = h[i]; while(cur)&#123; HashNode* de = cur; cur = cur-&gt;next; delete de; &#125; &#125;&#125;//BFS，返回目标状态在st数组下标int bfs(StateNode be) &#123; init_lookup_table( ); //初始化查找表,用于去重 queue&lt;StateNode&gt; StatQueue; StatQueue.push(be); while(!StatQueue.empty()) &#123; StateNode&amp; s = StatQueue.front(); if(memcmp(goal, s.stat, sizeof(s.stat)) == 0) return s.dist;//找到目标状态，成功返回 int z; for(z = 0; z &lt; 9; z++) if(!s.stat[z]) break; //找"0"的位置 int x = z/3, y = z%3; //获取行列编号（0~2） for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if(newx &gt;= 0 &amp;&amp; newx &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3)&#123; //如果移动合法 StateNode t; memcpy(&amp;t.stat, &amp;s.stat, sizeof(s.stat)); //扩展新结点 t.stat[newz] = s.stat[z]; t.stat[z] = s.stat[newz]; t.dist = s.dist+1; //更新新结点的距离值 if(try_to_insert(t)) StatQueue.push(t); //如果成功插入查找表，修改队尾指针 &#125; &#125; StatQueue.pop(); //扩展完毕后再修改队首指针 &#125; return 0; //失败&#125;int main( )&#123; StateNode sta; for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;sta.stat[i]); //起始状态 for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;goal[i]); //目标状态 int ans = bfs(sta); //返回目标状态的下标 if(ans &gt; 0) printf("%d\n", ans); else printf("-1\n"); deleteHash(head); return 0;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治-棋盘覆盖问题]]></title>
    <url>%2F2018%2F04%2F11%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 转自:分治法——棋盘覆盖问题 题目棋盘覆盖问题。有一个2k∗2k的方格棋盘，恰有一个方格是黑色的，其他为白色。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。如图所示为L型牌的4种旋转方式。 HINT分治三步骤划分问题：将2k∗2k的棋盘划分为2k−1∗2k−1这样的子棋盘4块。 递归求解：递归填充各个格子，填充分为四个情况，在下面会有解释，递归出口为k=0也就是子棋盘方格数为1。 合并问题：不需要合并子问题。 递归填充的四种情况如果黑方块在左上子棋盘，则递归填充左上子棋盘；否则填充左上子棋盘的右下角，将右下角看做黑色方块，然后递归填充左上子棋盘。 如果黑方块在右上子棋盘，则递归填充右上子棋盘；否则填充右上子棋盘的左下角，将左下角看做黑色方块，然后递归填充右上子棋盘。 如果黑方块在左下子棋盘，则递归填充左下子棋盘；否则填充左下子棋盘的右上角，将右上角看做黑色方块，然后递归填充左下子棋盘。 如果黑方块在右下子棋盘，则递归填充右下子棋盘；否则填充右下子棋盘的右下角，将左上角看做黑色方块，然后递归填充右下子棋盘。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;const int maxNum = 1 &lt;&lt; 10;// 棋盘int chess[maxNum][maxNum];// L型牌编号int number;void chessBoard(int row, int column, int x, int y, int siz) &#123; // 递归出口 if(siz == 1) &#123; return; &#125; // 对半划分成2^(siz - 1) * 2^(siz - 1)的棋盘 int s = siz / 2; // L型牌编号自增 int t = ++number; // 中间点，以此判别(x,y)在哪个子棋盘中 int centerRow = row + s; int centerColumn = column + s; // 黑色方格在左上子棋盘 if(x &lt; centerRow &amp;&amp; y &lt; centerColumn) &#123; chessBoard(row, column, x, y, s); &#125; else &#123; // 不在则填充左上子棋盘的右下角 chess[centerRow - 1][centerColumn - 1] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(row, column, centerRow - 1, centerColumn - 1, s); &#125; // 黑色方格在右上子棋盘 if(x &lt; centerRow &amp;&amp; y &gt;= centerColumn) &#123; chessBoard(row, centerColumn, x, y, s); &#125; else &#123; // 不在则填充右上子棋盘的左下角 chess[centerRow - 1][centerColumn] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(row, centerColumn, centerRow - 1, centerColumn, s); &#125; // 黑色方格在左下子棋盘 if(x &gt;= centerRow &amp;&amp; y &lt; centerColumn) &#123; chessBoard(centerRow, column, x, y, s); &#125; else &#123; // 不在则填充左下子棋盘的右上角 chess[centerRow][centerColumn - 1] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(centerRow, column, centerRow, centerColumn - 1, s); &#125; // 黑色方格在右下子棋盘 if(x &gt;= centerRow &amp;&amp; y &gt;= centerColumn) &#123; chessBoard(centerRow, centerColumn, x, y, s); &#125; else &#123; // 不在则填充右下子棋盘的左上角 chess[centerRow][centerColumn] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(centerRow, centerColumn, centerRow, centerColumn, s); &#125;&#125;int main() &#123; // 大小，黑色方格位置 int siz, x, y; while(true) &#123; cout &lt;&lt; "(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。" &lt;&lt; endl; cout &lt;&lt; "请输入棋盘大小和黑色方格位置(x,y)："; cin &gt;&gt; siz &gt;&gt; x &gt;&gt; y; // 退出条件 if(siz == 0) &#123; break; &#125; // 涂黑(x,y)，初始化L型牌编号 chess[x][y] = number = 1; // 分治法填满棋盘 chessBoard(0, 0, x, y, siz); // 输出该棋盘 for(int i = 0; i &lt; siz; i++) &#123; for(int j = 0; j &lt; siz; j++) &#123; cout &lt;&lt; chess[i][j] &lt;&lt; "\t"; &#125; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; &#125; &#125; return 0;&#125; 测试输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：2 0 01 22 2(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：4 1 13 3 4 43 1 2 45 2 2 65 5 6 6(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：8 2 24 4 5 5 9 9 10 104 3 3 5 9 8 8 106 3 1 7 11 11 8 126 6 7 7 2 11 12 1214 14 15 2 2 19 20 2014 13 15 15 19 19 18 2016 13 13 17 21 18 18 2216 16 17 17 21 21 22 22(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：0 0 0Process returned 0 (0x0) execution time : 29.988 sPress any key to continue. 总结]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa806 习题6-8 空间结构（Spatial Structures,ACM/ICPC World Finals 1998）]]></title>
    <url>%2F2018%2F04%2F10%2FUVa806-%E4%B9%A0%E9%A2%986-8-%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%EF%BC%88Spatial-Structures-ACM-ICPC-World-Finals-1998%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目黑白图像有两种表示法：点阵表示和路径表示。路径表示法首先需要把图像转化为四分 树，然后记录所有黑结点到根的路径。例如，对于如图6-25所示的图像。 四分树如图6-26所示。 NW、NE、SW、SE分别用1、2、3、4表示。最后把得到的数字串看成是五进制的，转 化为十进制后排序。例如上面的树在转化、排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。你的任务是在这两种表示法之间进行转换。在点阵表示法中，1表示黑色，0表示白色。图像总是正方形的，且长度n为2的整数幂，并满足n≤64。输入输出细节请参见原题。 HINT代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;valarray&gt;#include &lt;vector&gt;using namespace std;#define _for(i, a, b) for (int i = (a); i &lt; (b); ++i)#define _rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)typedef long long LL;/* NW = 1, NE = 2, SW = 3, SE = 4 */const int MAXN = 64 + 4, DX[] = &#123;0, 0, 1, 1&#125;, DY[] = &#123;0, 1, 0, 1&#125;;int N;char IMG[MAXN][MAXN];void countBlack(int x, int y, int len, vector&lt;int&gt;&amp; ans, int path = 0, int p5 = 1) &#123; int f = 0, len2 = len / 2; _for(i, x, x + len) _for(j, y, y + len) f += IMG[i][j] - '0'; if (f == 0) return; if (f == len * len) &#123; ans.push_back(path); return; &#125; _for(di, 0, 4) countBlack(x+DX[di]*len2, y+DY[di]*len2, len2, ans, path+p5*(di+1), p5*5);&#125;void draw(int path, int x, int y, int len) &#123; if (path == 0) &#123; assert(len); _for(i, x, x + len) _for(j, y, y + len) IMG[i][j] = '*'; return; &#125; int di = path % 5 - 1, len2 = len / 2; draw(path / 5, x + DX[di] * len2, y + DY[di] * len2, len2);&#125;int main() &#123; for (int kase = 1; scanf("%d", &amp;N) == 1 &amp;&amp; N; kase++) &#123; if (kase &gt; 1) puts(""); printf("Image %d\n", kase); if (N &gt; 0) &#123; _for(i, 0, N) scanf("%s", IMG[i]); vector&lt;int&gt; blacks; countBlack(0, 0, N, blacks); sort(begin(blacks), end(blacks)); int sz = blacks.size(); _for(i, 0, sz) printf("%d%s", blacks[i], (i % 12 == 11 || i == sz - 1) ? "\n" : " "); printf("Total number of black nodes = %d\n", sz); &#125; else &#123; int p; memset(IMG, 0, sizeof(IMG)); N = -N; _for(i, 0, N) _for(j, 0, N) IMG[i][j] = '.'; while (scanf("%d", &amp;p) == 1 &amp;&amp; p &gt;= 0) draw(p, 0, 0, N); _for(i, 0, N) puts(IMG[i]); &#125; &#125; return 0;&#125; 总结]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 804 - Petri Net Simulation（模拟）]]></title>
    <url>%2F2018%2F04%2F10%2FUVa-804-Petri-Net-Simulation%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目描述你的任务是模拟Petri网的变迁。Petri网包含NP个库所（用P1，P2…表示）和NT个变迁 （用T1，T2…表示）。0&lt;NP, NT&lt;100。当每个变迁的每个输入库所都至少有一个token时， 变迁是允许的。变迁发生的结果是每个输入库所减少一个token，每个输出库所增加一个 token。变迁的发生是原子性的，即所有token的增加和减少应同时进行。注意，一个变迁可 能有多个相同的输入或者输出。如果一个库所在变迁的输入库所列表中出现了两次，则token 会减少两个。输出库所也是类似。如果有多个变迁是允许的，一次只能发生一个。如图6-24所示，一开始只有T1是允许的，发生一次T1变迁之后有一个token会从P1移动到P2，但仍然只有T1是允许的，因为T2要求P2有两个token。再发生一次T1变迁之后P1中只 剩一个token，而P2中有两个，因为T1和T2都可以发生。假定T2发生，则P2中不再有token，而P3中有一个token，因此T1和T3都是允许的。 HINT输入一个Petri网络。初始时每个库所都有一个token。每个变迁用一个整数序列表示，负 数表示输入库所，正数表示输出库所。每个变迁至少包含一个输入和一个输出。最后输入一 个整数NF，表示要发生NF次变迁（同时有多个变迁允许时可以任选一个发生，输入保证这个选择不会影响最终结果）。 依次对每个T(i)进行执行，如果每个input都能执行成功（NP中有token）则执行，则执行output，并将执行T(i)的次数++，否则恢复刚才所有执行的input。一轮（将所有T(i)执行一遍）中任意一个T(i)执行就可以执行下一轮。如果一轮中没有任何一个T(i)执行成功则说明执行失败，返回执行次数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int deal();const int MAXN = 100 + 10;int NP[MAXN]; //P(i)现存小球的数量int NT_in[MAXN][MAXN]; //存储T(i)的inputint NT_out[MAXN][MAXN]; //存储T(i)的outputint n, m, num;int main()&#123; int kase = 0; while (cin &gt;&gt; n &amp;&amp; n) &#123; //初始化 memset(NT_in,0,sizeof(NT_in)); memset(NT_out, 0, sizeof(NT_out)); int k,i, j, x, do_num; for (i = 1; i &lt;= n; i++) cin &gt;&gt; NP[i]; cin &gt;&gt; m; for (i = 0; i &lt; m; i++)&#123; k = j = 0; while (cin &gt;&gt; x &amp;&amp; x)&#123; if (x &lt; 0) NT_in[i][j++] = x; else NT_out[i][k++] = x; &#125; &#125; cin &gt;&gt; num; //处理 do_num = deal(); //处理函数，返回执行变迁的次数 //输出 if(do_num == num) cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": still live after " &lt;&lt; do_num &lt;&lt; " transitions\n"; else cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": dead after " &lt;&lt; do_num &lt;&lt; " transitions\n"; cout &lt;&lt; "Places with tokens:"; for (int i = 1; i &lt;= n; i++) //逐个输出有token的P,和个数 if (NP[i] &gt; 0) cout &lt;&lt; " " &lt;&lt; i &lt;&lt; " (" &lt;&lt; NP[i] &lt;&lt; ")"; cout &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125;/*依次对每个T(i)进行执行，如果每个input都能执行成功（NP中有token）则执行，则执行output，并将执行T(i)的次数++，否则恢复刚才所有执行的input。一轮（将所有T(i)执行一遍）中任意一个T(i)执行就可以执行下一轮。如果一轮中没有任何一个T(i)执行成功则说明执行失败，返回执行次数。*/int deal()&#123; int i, j, n = 1; while(1) &#123; bool had_do = false; //该轮中有T(i)执行，可以执行下一轮 for (i = 0; i &lt; m; i++)&#123; j = 0; bool can_do = true;//该T(i)执行是否成功 while (NT_in[i][j] != 0)&#123; if (NP[-NT_in[i][j]] &gt; 0) //执行input NP[-NT_in[i][j++]]--; else&#123; //input执行失败，恢复input之前状态，并将can_do置为false while (j--) NP[-NT_in[i][j]]++; can_do = false; break; &#125; &#125; if (can_do) &#123; //input执行成功的情况下执行output j = 0; n++;//*** while (NT_out[i][j] != 0)&#123; NP[NT_out[i][j]]++; j++; &#125; had_do = true; if (n &gt; num) return num; &#125; else break; &#125; if (!had_do) return n-1; &#125;&#125; 总结重点在于理解题意]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim基本使用]]></title>
    <url>%2F2018%2F03%2F23%2Fvim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vim的基本使用 Vim键盘分布图 Vim树状图]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法小计B1]]></title>
    <url>%2F2018%2F03%2F20%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%A1B1%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 2018-3-20P60近似计算123456789101112131415161718#include &lt;math.h&gt;int main()&#123; int i = 0; double sum = 0; double term; do&#123; term = 1.0/(2*i+1);//注意写成1.0而不是1 sum+=pow(-1,i)*term; ++i; &#125;while(term&gt;=pow(10, -6)); cout&lt;&lt;sum; return 0;&#125; P62阶乘之和 要计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在每步计算之后对n取余，结果不变。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;time.h&gt;int main()&#123; const int MOD = 1000000; int n, S = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; int factorial = 1; for(int j = 1; j &lt;= i; j++) factorial = (factorial * j % MOD); S = (S + factorial) % MOD; &#125; printf("%d\n", S); printf("Time used = %.2f\n", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; P94键盘输入12345678910111213141516string s = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";// 这里s为47个char，s[47] = nullint main() &#123; int i, c; while((c = getchar())!=EOF)&#123; for (i = 1; s[i]&amp;&amp;s[i]!=c ; ++i); if (s[i])//如果找不到 s[47] = null putchar(s[i-1]); else putchar(c); &#125; return 0;&#125; 2018-3-21P140刽子手 关键在于设立win和lose以及bad的标志位，没猜一个更新标志位 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 100int left, chance; //还需要猜left个位置,错chance次之后就会输char s[maxn], s2[maxn]; //答案是字符串s,玩家猜的字母序列是s2int win, lose; //win=1表示已经赢了;lose=1表示已经输了void guess(char ch) ;int main() &#123; int rnd; while(scanf("%d%s%s", &amp;rnd, s, s2) == 3 &amp;&amp; rnd != -1) &#123; printf("Round %d\n", rnd); win = lose = 0; //求解一组新数据之前要初始化 left = strlen(s); chance =7; for(int i = 0; i &lt; strlen(s2); i++) &#123; guess(s2[i]); //猜一个字母 if(win || lose) break; //检查状态 &#125; //根据结果进行输出 if(win) printf("You win.\n"); else if(lose) printf("You lose.\n"); else printf("You chickened out.\n"); &#125; return 0;&#125;void guess(char ch) &#123; int bad = 1; for(int i = 0; i &lt; strlen(s); i++) if(s[i] == ch) &#123; left--; s[i] = ' '; bad = 0; &#125; if(bad) --chance; if(!chance) lose = 1; if(!left) win = 1;&#125; P145信息编码 使用char code[n][1&lt;&lt;n]存放编码本，n。前面的n表示二进制长度，后面的表示该二进制数的十进制表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;string.h&gt; //使用memsetint readchar() ;int readint(int c) ;int code[8][1&lt;&lt;8];int readcodes() ;int main() &#123; while(readcodes()) &#123; //无法读取更多编码头时退出//printcodes(); for(;;) &#123; int len = readint(3); if(len == 0) break;//printf("len=%d\n", len); for(;;) &#123; int v = readint(len);//printf("printf("v=%d\n", v); if(v == (1 &lt;&lt; len)-1) break; putchar(code[len][v]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;int readchar() &#123; for(;;) &#123; int ch = getchar(); if(ch != '\n' &amp;&amp; ch != '\r') return ch; //一直读到非换行符为止 &#125;&#125;int readint(int c) &#123; int v = 0; while(c--) v = v * 2 + readchar() - '0'; return v;&#125;// 生成编码本int readcodes() &#123; memset(code, 0, sizeof(code)); //清空数组 code[1][0] = readchar(); //直接调到下一行开始读取。如果输入已经结束，会读到EOF for(int len = 2; len &lt;= 7; len++) &#123; for(int i = 0; i &lt; (1&lt;&lt;len)-1; i++) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\n' || ch == '\r') return 1; code[len][i] = ch; &#125; &#125; return 1;&#125; 2018-3-24北邮OJ-11网研第三题-中序遍历树题目描述给一棵树，你可以把其中任意一个节点作为根节点。每个节点都有一个小写字母，中序遍历，得到一个字符串，求所有能得到的字符串的字典序最小串。因为这棵树不一定是二叉树，所以中序遍历时，先中序遍历以节点序号最小的节点为根的子树，然后再遍历根节点，最后根据节点序号从小到大依次中序遍历剩下的子树。 HINT意思就是请枚举所有的点为根，然后中序遍历最后输出所有结果中字典序最小的比如说第二组数据以0为根时结果为 bacd以1为根时结果为 cadb 以2为根时结果为 badc以3为根时结果为 bacd所以字典序最小的是bacd 输入格式多组数据，以EOF结束。 第一行一个数n（0&lt; n &lt; =100）,表示树的节点的个数，节点从0开始。 然后一个长度为n的串，第i（0&lt; = i &lt; n）个字符表示节点i的字符。接下来n-1行，每行两个数a，b,(0&lt; = a,b &lt; n),表示a和b之间有一条无向边。 输出格式题中要求的最小的字符串 输入样例3 bac 0 1 1 2 4 abcd 0 1 0 2 0 3 输出样例bac bacd 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;char func[101];bool relation[100][100]=&#123;false&#125;;bool visited[100]=&#123;false&#125;;string result;string temp;void dfs(int pos,int n)&#123; int son[100]; int size=0; visited[pos]=true; for(int j=0;j&lt;n;j++) &#123;// if(j==pos)continue; if(relation[pos][j]==true&amp;&amp;!visited[j]) &#123; son[size++]=j; &#125; &#125; if(size&gt;0) &#123; dfs(son[0],n); temp+=func[pos]; for(int j=1;j&lt;size;j++) &#123; dfs(son[j],n); &#125; &#125; else if(size==0)temp+=func[pos];&#125;int main()&#123; int n,a,b,t; while(cin&gt;&gt;n) &#123; result=""; temp=""; cin&gt;&gt;func; t=n; t--; memset(relation,0,sizeof(relation)); //cout&lt;&lt;relation[99][99]; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; relation[a][b]=true; relation[b][a]=true; &#125; int it=-1; for(int i=0;i&lt;n;i++) &#123; memset(visited,0,sizeof(visited)); dfs(i,n); // cout&lt;&lt;"以"&lt;&lt;i&lt;&lt;"("&lt;&lt;func[i]&lt;&lt;")"&lt;&lt;"为根"&lt;&lt;temp&lt;&lt;endl; if(i==0)&#123; result=temp;it=i;&#125; else if(result&gt;temp)&#123; result=temp;it=i;&#125; temp=""; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125;&#125; 2018-3-25P186反片语HINT这里的map用于统计字符串的数量，如果出现两次则不输出。注意此时的key应该是标准化的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;string lowerstr(const string&amp; s)&#123; string ss = s; for (auto it = ss.begin(); it != ss.end() ; ++it) &#123; *it = tolower(*it); &#125; sort(ss.begin(), ss.end());// 核心 return ss;&#125;int main()&#123; vector&lt;string&gt; strvec; map&lt;string, int&gt; strmap; string str; while(cin&gt;&gt;str)&#123; if (str[0] == '#') break; strvec.push_back(str); string strlower = lowerstr(str); if (!strmap.count(strlower)) strmap[strlower] = 0; ++strmap[strlower]; &#125; vector&lt;string&gt; vec; for (auto it = strvec.begin(); it != strvec.end() ; ++it) &#123; if (strmap[lowerstr(*it)] == 1) vec.push_back(*it); &#125; sort(vec.begin(), vec.end()); for (int i = 0; i &lt; vec.size(); ++i) &#123; cout&lt;&lt;vec[i]&lt;&lt;endl; &#125;&#125; p189集合栈HINT使用vector存放集合，并把其和其在vector中的下标映射成map（因为ID是唯一的，避免每次查找vector使用map），stack中只需要存ID 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define ALL(x) x.begin(),x.end()#define INS(x) inserter(x,x.begin())typedef set&lt;int&gt; Set;vector&lt;Set&gt; vec;map&lt;Set, int&gt; smap;int ID(Set s)&#123; if (smap.count(s)) return smap[s]; vec.push_back(s); return smap[s] = vec.size() - 1;&#125;int main()&#123; string cmd; stack&lt;int&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;cmd; Set x = Set(); int s1,s2; switch (cmd[0]) &#123; case 'P': st.push(ID(Set())); break; case 'D': st.push(st.top()); break; case 'U': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); set_union(ALL(vec[s1]), ALL(vec[s2]), INS(x)); st.push(ID(x)); break; case 'I': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); set_intersection(ALL(vec[s1]), ALL(vec[s2]), INS(x)); st.push(ID(x)); break; case 'A': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); x = vec[s2]; x.insert(ID(vec[s1])); st.push(ID(x)); break; default: cout&lt;&lt;"error!"; break; &#125; cout&lt;&lt;vec[st.top()].size()&lt;&lt;endl; &#125;&#125; P195 丑数HINTpriority_queue]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App场景分析与建模识别方法]]></title>
    <url>%2F2018%2F03%2F20%2FApp%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E4%B8%8E%E5%BB%BA%E6%A8%A1%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[提取出APP的UI信息，如控件的名字、坐标、尺寸、类名、内存，以及控件的树状层级关系，寻找方法通过这些UI信息得到APP当前的场景和动作，建立模型，输入为UIInfo(e.g.[[UIApp keyWindow] recursiveDescription])，输出为APPScene(e.g.发送搜索请求)。 前言提取出APP的UI信息，如控件的名字、坐标、尺寸、类名、内存，以及控件的树状层级关系，寻找方法通过这些UI信息得到APP当前的场景和动作，建立模型，输入为UIInfo(e.g.[[UIApp keyWindow] recursiveDescription])，输出为APPScene(e.g.发送搜索请求)。 想法app场景识别 App scene recognition基于文本的app场景识别 Text-based App scene recognition app行为的定义，是否能通过类名、坐标就简单定义行为。app行为和用户行为的关联。如何定义是首要的。 除了[[UIApp keyWindow] recursiveDescription]还能使用什么方法获取UIinfo 如何建模，是否用机器学习，如何将输入向量化。 场景识别(机器学习)介绍计算机视觉和场景识别的前世今生 场景识别论文阅读感想（初步） MIT Scene Recognition Demo识别图片是在室内还是室外 参考文献面向事件关系检测的特征分析与场景推理方法研究 Multi-spectral SIFT for scene category recognition Convolutional Network Features for Scene Recognition SUN database: Large-scale scene recognition from abbey to zoo Learning deep features for scene recognition using places database Scene Recognition with CNNs: Objects, Scales and Dataset Bias 机器学习和深度学习引用量最高的20篇论文（2014-2017）]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的模式匹配-BF和KMP算法]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-BF%E5%92%8CKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[母串匹配子串的常用算法，定义Tag为主串，Ptn为子串（模式串），如果在主串Tag的第pos个位置后存在与子串Ptn相同的子串，返回它在主串Tag中第pos个字符后第一次出现的位置，否则返回-1。BF算法为暴力回溯求解算法，KMP算法相对优化。 BF算法思路定义两个索引值i和j分别为Tag和Ptn的带匹配字符，匹配则自增，不匹配则i回溯为i-j+1，j回溯为0，当二者有其一索引至尾端则跳出循环，若跳出循环后j索引完了Ptn则返回i-length（Ptn），否则返回-1。 代码12345678910111213141516171819202122232425262728293031323334/*返回子串Ptn在主串Tag的第pos个字符后(含第pos个位置)第一次出现的位置，若不存在，则返回-1采用BF算法，这里的位置全部以从0开始计算为准，其中T非空，0&lt;=pos&lt;=Tlen*/int index(const string &amp;Tag,const string &amp;Ptn,int pos)&#123; int i = pos; //主串当前正待比较的位置，初始为pos int j = 0; //子串当前正待比较的位置，初始为0 int Tlen = Tag.size(); //主串长度 int Plen = Ptn.size(); //子串长度 while(i&lt;Tlen &amp;&amp; j&lt;Plen) &#123; if(Tag[i] == Ptn[j]) //如果当前字符相同，则继续向下比较 &#123; i++; j++; &#125; else //如果当前字符不同，则i和j回退，重新进行匹配 &#123; //用now_pos表示每次重新进行匹配时开始比较的位置，则 //i=now_pos+后移量，j=0+后移量 //则i-j+1=now_pos+1,即为Tag中下一轮开始比较的位置 i = i-j+1; //Ptn退回到子串开始处 j = 0; &#125; &#125; if(j &gt;= Plen) return i - Plen; else return -1;&#125; 验证123456789101112131415161718192021222324int main()&#123; char ch; do&#123; string Tag,Ptn; int pos; cout&lt;&lt;"输入主串："; cin&gt;&gt;Tag; cout&lt;&lt;"输入子串："; cin&gt;&gt;Ptn; cout&lt;&lt;"输入主串中开始进行匹配的位置（首字符位置为0）："; cin&gt;&gt;pos; int result = index(Tag,Ptn,pos); if(result != -1) cout&lt;&lt;"主串与子串在主串的第"&lt;&lt;result&lt;&lt;"个字符（首字符的位置为0）处首次匹配"&lt;&lt;endl; else cout&lt;&lt;"无匹配子串"&lt;&lt;endl; cout&lt;&lt;"是否继续测试（输入y或Y继续，任意其他键结束）："; cin&gt;&gt;ch; &#125;while(ch == 'y' || ch == 'Y'); return 0;&#125; KMP算法思路 回溯的方法不同，一旦失配，i不回溯，j回溯到一个特殊的位置，采用next[length(Ptn)]记录元素失配后回溯到的下一位置。 关键在与next数组的求解，下面举例。key：next数组是针对子串的，和母串没关。 next数组理解的举例 对于子串“ABCDABD”，对应的next数组为“-1 0 0 0 0 1 2”，下面解释next数组怎么来的。 当匹配到第六位的“B”时，如果发生了失配，j将回到1即第二位开始配，因为失配位的前一位是A，而A在子串的最开头出现过，所以j没必要回溯到0再开始匹配了。 当匹配到第七位的“D”时，如果发生了失配，j将回到2即第三位开始配，因为失配位的前两位是AB，而AB在子串的最开头出现过，所以j没必要回溯到0再开始匹配了，直接从第三位开始匹配。 所以next数组记录的是，当前位置元素往前看，比如D往前看，出现的连续字符满足和从头开始数连续字符相等的数量。比如从D往前看为AB，所以D对应2。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*返回子串Ptn在主串Tag的第pos个字符后(含第pos个位置)第一次出现的位置，若不存在，则返回-1采用KMP算法，这里的位置全部以从0开始计算为准，其中T非空，0&lt;=pos&lt;=Tlen*/int kmp_index(const string &amp;Tag,const string &amp;Ptn,int pos)&#123; int i = pos; //主串当前正待比较的位置，初始为pos int j = 0; //子串当前正待比较的位置，初始为0 int Tlen = Tag.size(); //主串长度 int Plen = Ptn.size(); //子串长度 //求next数组的值，并逐个输出 int *next = (int *)malloc(Plen*sizeof(int)); get_next(Ptn,next,Plen);// get_nextval(Ptn,next,Pln); int t; cout&lt;&lt;"子串的next数组中的各元素为："; for(t=0;t&lt;Plen;t++) cout&lt;&lt;next[t]&lt;&lt;" "; cout&lt;&lt;endl; while(i&lt;Tlen &amp;&amp; j&lt;Plen) &#123; if(j==-1 || Tag[i] == Ptn[j]) &#123; //如果当前字符相同，或者在子串的第一个字符处失配，则继续向下比较 i++; j++; &#125; else //如果当前字符不同，则i保持不变，j变为下一个开始比较的位置 &#123; //next数组时KMP算法的关键，i不回退， //而是继续与子串中的nex[j]位置的字符进行比较 j = next[j]; &#125; &#125; if(j &gt;= Plen) return i - Plen; else return -1;&#125;/*求next数组中各元素的值，保存在长为len的next数组中*/void get_next(const string &amp;Ptn,int *next,int len)&#123; int j = 0; int k = -1; next[0] = -1; while(j&lt;len-1) &#123; if(k == -1 || Ptn[j] == Ptn[k]) &#123; //如果满足上面分析的Pk = Pj的情况，则继续比较下一个字符， //并得next[j+1]=next[j]+1 j++; k++; next[j] = k; &#125; else &#123; //如果符合上面分析的第2种情况，则依据next[k]继续寻找下一个比较的位置 k = next[k]; &#125; &#125;&#125;/*求next数组的改进数组中各元素的值，保存在长为len的nextval数组中*/void get_nextval(const string &amp;Ptn,int *nextval,int len)&#123; int j = 0; int k = -1; nextval[0] = -1; while(j&lt;len-1) &#123; if(k == -1 || Ptn[j] == Ptn[k]) &#123; //如果满足上面分析的Pk = Pj的情况，则继续比较下一个字符， //并得next[j+1]=next[j]+1 j++; k++; if(Ptn[j] != Ptn[k]) nextval[j] = k; else //Ptn[j]与Ptn[k]相等时，直接跳到netval[k] nextval[j] = nextval[k]; &#125; else &#123; //如果符合上面分析的第2种情况，则依据next[k]继续寻找下一个比较的位置 k = nextval[k]; &#125; &#125;&#125; 验证123456789101112131415161718192021222324int main()&#123; char ch; do&#123; string Tag,Ptn; int pos; cout&lt;&lt;"输入主串："; cin&gt;&gt;Tag; cout&lt;&lt;"输入子串："; cin&gt;&gt;Ptn; cout&lt;&lt;"输入主串中开始进行匹配的位置（首字符位置为0）："; cin&gt;&gt;pos; int result = kmp_index(Tag,Ptn,pos); if(result != -1) cout&lt;&lt;"主串与子串在主串的第"&lt;&lt;result&lt;&lt;"个字符（首字符的位置为0）处首次匹配"&lt;&lt;endl; else cout&lt;&lt;"无匹配子串"&lt;&lt;endl; cout&lt;&lt;"是否继续测试（输入y或Y继续，任意其他键结束）："; cin&gt;&gt;ch; &#125;while(ch == 'y' || ch == 'Y'); return 0;&#125; 参考链接 【数据结构与算法】模式匹配——从BF算法到KMP算法（附完整源码） 从头到尾彻底理解KMP]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo多终端部署持续更新]]></title>
    <url>%2F2018%2F03%2F18%2Fhexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[使用hexo+git写博客十分简便高效，然而多终端的部署问题有很多坑，本博客将持续更新在多终端部署时遇到的坑。 基本方法安装git并设置关联什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash 或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后直接三个回车即可，默认不需要设置密码 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制打开GitHub_Settings_keys 页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com ： 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 检测npm是否安装成功，在命令行中输入npm -v : 到这了，安装Hexo的环境已经全部搭建完成。 github设置 在yourname.github.io仓库内创建一个新的branch，如：hexo。 将该分支设置为默认分支settings -&gt; branch -&gt; Default branch -&gt; update 在本地建立git仓库 配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public 进入blog文件夹，shift+右键打开终端 git init Initialized empty Git repository初始化git仓库 git add -A 添加本地所有文件 git commit -m &quot;blog source files&quot; 提交到本地仓库 git branch hexo 创建本地hexo分支 将本地仓库与远端关联 git remote add origin git@github.com:yourname/yourname.github.io.git 添加远程仓库 git push origin hexo -f 将本地仓库推到远端仓库(默认为hexo分支) 另一终端的所有操作 将远程clone至本地 git clone -b hexo git@github.com:yourname/yourname.github.io.git 进入clone下来的仓库以及next主题文件夹下执行安装(会根据package.json安装对应的依赖) npm install 编辑本地文件后更新远程 git add . ,git commit -m &quot;update info&quot;， git push origin hexo 部署发布博客 hexo clean hexo g -d 踩坑记暂无]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[已知中序和前序（或后序）遍历结果生成树]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%B7%B2%E7%9F%A5%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%EF%BC%88%E6%88%96%E5%90%8E%E5%BA%8F%EF%BC%89%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[如题，已知中序和前序（或后序）遍历结果生成树，算法分为两部分，一部分为已知前序和中序，另一部分为已知后序和中序。 思路已知前序和中序 定位树根，树根即当前前序的首节点。 定位树根位于中序的位置，该位置左边即左子树，右边即右子树。 递归左右子树。 已知后序和中序同理 举例 已知 后序序列 LHDKEBFGCA 中序序列 HLDBEKAFCG 求解 由后序序列定位树根，树根为A 节点A的左子树的中序为HLDBEK，左子树的后序为LHDKEB，右子树的中序为FCG，右子树的后序为FGC 对于左子树，树根为B，继续第二步，对于右子树，树根为G，继续第二步。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//// Created by Jumormt on 2018/3/17.//#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Node&#123; Node(char v='0'):value(v), left(0), right(0)&#123;&#125; char value; Node* left; Node* right;&#125;;char pre[50] = "ABDHLEKCFG"; //前序序列char mid[50] = "HLDBEKAFCG"; //中序序列char post[50] = "LHDKEBFGCA"; //后序序列class BiTree&#123;public: BiTree(Node* n):root(n)&#123;&#125; // 定位c在中序遍历的位置 int Position(char c) &#123; return strchr(mid,c)-mid; &#125;// // 数组初始化树的方法// // 注意要传入指针的引用，因为函数内试图改变指针的大小R=new Node;不加引用就是无效改变！！另外R-&gt;value = ch[i];是确实会改变传入指针所指对象的。// void Create(Node *&amp;R, int i)// &#123;// if (ch[i]==0)// R = NULL;// else// &#123;// R=new Node;// R-&gt;value = ch[i];// Create(R-&gt;left, 2*i);// Create(R-&gt;right, 2*i+1);// &#125;// &#125; // 已知前序和中序遍历整个树 注意传入新参为Node*&amp; root，因为函数内试图改变指针的大小root=new Node;不加引用就是无效改变！！另外root-&gt;value = pre[i];是确实会改变传入指针所指对象的。 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PreMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = pre[i]; int pos = Position(pre[i]); int lenL = pos - j; int lenR = length - lenL - 1; PreMidCreate(root-&gt;left, i+1, j, lenL); PreMidCreate(root-&gt;right, i+1+lenL, pos+1, lenR); &#125; // 已知后序和中序遍历整个树 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PostMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = post[i]; int pos = Position(post[i]); int lenL = pos - j; int lenR = length - lenL - 1; PostMidCreate(root-&gt;left, i-1-lenR, j, lenL); PostMidCreate(root-&gt;right, i-1, pos+1, lenR); &#125; //前序遍历 void preOrder(Node* root)&#123; if (root)&#123; cout&lt;&lt;root-&gt;value&lt;&lt;" "; preOrder(root-&gt;left); preOrder(root-&gt;right); &#125; &#125; // 中序遍历 void midOrder(Node* root)&#123; if (root)&#123; midOrder(root-&gt;left); cout&lt;&lt;root-&gt;value&lt;&lt;" "; midOrder(root-&gt;right); &#125; &#125; // 后序遍历 void postOrder(Node* root)&#123; if (root)&#123; postOrder(root-&gt;left); postOrder(root-&gt;right); cout&lt;&lt;root-&gt;value&lt;&lt;" "; &#125; &#125; void deleteTree(Node* node)&#123; if (node)&#123; deleteTree(node-&gt;left); deleteTree(node-&gt;right); delete node; &#125; &#125; ~BiTree()&#123; deleteTree(root); &#125; Node* getRoot()&#123; return root; &#125;private: Node* root;&#125;;int main()&#123; Node* node = new Node(); BiTree tree(node); tree.PreMidCreate(node, 0, 0, strlen(mid)); tree.preOrder(node);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划-大四下]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%AE%A1%E5%88%92-%E5%A4%A7%E5%9B%9B%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本科还剩下1/8，最后半年承上启下，希望对本科阶段的学习有所总结，对研究生生活有所准备，列下一个粗略的计划希望时间不会虚度。 学习毕业设计毕设需要完成一个较大的工程项目，需要掌握每个模块涉及的技术，包括爬虫、clamav和cuckoo、调度、Web。 逆向完善敏感api组合，完善cuckoo process和signature的自定义。 调度学习使用java语言，掌握基本的架构设计方案，学习thrift跨语言接口定义。 Web基本H5 + JAVA + springMVC 安全修满6学分的研究生课程，系统地学习一下信息安全技术。 智能学完之前未看完的视频，熟悉一下一些主流的框架，了解神经网络的基本应用。 算法《算法导论》+ 《算法竞赛入门经典》+ leetcode，语言使用cpp，每天定量。 未完待续健身吉他阅读kindle unlimited每周一本开始 写在最后希望能坚持写博客，记录平时的学习过程和心得感悟，在技术上和思想上都能有一定升华，望监督。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy+PhantomJS+Selenium实现动态网页的爬取]]></title>
    <url>%2F2018%2F02%2F08%2FScrapy-PhantomJS-Selenium%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[网络爬虫是数据挖掘的重要前提，通过网络爬虫可以自动化批量获取互联网上你需要的有用信息。爬虫于静态页面的爬取十分简单，但Ajax的出现实现了网页的局部动态加载，网页不需每次返回重复Html而只要局部刷新，简单的静态页面爬虫只能解析单一url而对它就无能为力了。PhantomJS+Selenium，再加上Scrapy爬虫框架，就可以实现动态爬虫。 PhantomJSPhantomJS是什么？ PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS官方地址 PhantomJS官方API PhantomJS官方示例 PhantomJS GitHub PhantomJS的使用PhantomJS的安装不再赘述，在windows平台下安装好的phantomjs.exe即可可通过JS与webkit内核交互。12345678910111213// GetHtml.jsvar page = require('webpage').create(), //获取操作dom或web网页的对象 system = require('system'), //获取操作系统对象 address;if (system.args.length === 1) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; page.open(address, function (status) &#123; //访问url console.log(page.content); phantom.exit(); &#125;);&#125; 控制台输入1phantomjs ./test.js http://baidu.com 即打印输出百度的html页面 PhantomJS参考链接 PhantomJS快速入门 phantomjs2.1 初体验 Selenium什么是Selenium？ selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。 Selenium的使用安装直接使用pip安装，详细使用详解参见参考链接，以下为简单使用介绍，即完全加载一个url（未考虑人工加载）123456// test.pyfrom selenium import webdriver driver = webdriver.PhantomJS(/path/to/PhantomJS.excuatable) # 获取浏览器对象driver.get('http://www.baidu.com/')print (driver.page_source) 参考链接 selenium用法详解 Scrapy不再赘述，直接丢出文档 PhantomJS+Selenium+Scrapy在爬虫.py中的request加入meta1request.meta[&apos;PhantomJS&apos;] = True 定义中间件1234567891011121314//JSMiddleware.pyfrom selenium import webdriverfrom scrapy.http import HtmlResponseclass PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS(executable_path='/path/to/phantomjs') driver.get(request.url) content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) settings中开启中间件1234DOWNLOADER_MIDDLEWARES = &#123; &apos;scrapy.contrib.downloadermiddlewares.useragent.UserAgentMiddleware&apos;: None, &apos;[爬虫名字].middlewares.PhantomJSMiddleware&apos;: 500,&#125; 改进-实现滚动刷新 js代码如下 12345678910111213141516171819202122// scrollToBottom.jsfunction scrollToBottom() &#123; var Height = document.body.clientHeight, //文本高度 screenHeight = window.innerHeight, //屏幕高度 INTERVAL = 100, // 滚动动作之间的间隔时间 delta = 500, //每次滚动距离 curScrollTop = 0; //当前window.scrollTop 值 var scroll = function () &#123; curScrollTop = document.body.scrollTop; window.scrollTo(0,curScrollTop + delta); &#125;; var timer = setInterval(function () &#123; var curHeight = curScrollTop + screenHeight; if (curHeight &gt;= Height)&#123; //滚动到页面底部时，结束滚动 clearInterval(timer); &#125; scroll(); &#125;, INTERVAL)&#125; 重新定义中间件 12345678910111213141516171819202122js = """// scrollToBottom.jsfunction scrollToBottom() &#123; ....&#125;scrollToBottom()"""class PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS() driver.get(request.url) driver.execute_script(js) time.sleep(1) # 等待JS执行 content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) time.sleep(&lt;wait_time&gt;)为了解决等待JS执行的时间过短会导致爬取的页面靠近底部的图片没能加载，因为滚动函数还未执行到此处。所以需要预留一个稍微长一点的等待时间。 实战参考链接 在Scrapy框架下使用Selenium+PhantomJS]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F02%2F07%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[习惯使用Markdown写博文，以下为Markdown基本语法。 标题This is an H1This is an H2这是 H1这是 H2这是 H6 特殊字符&copy; 区块引用 Blockquotes This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表 Red Green Blue Red Green Blue Red Green Blue Bird McHale Parish Bird McHale Parish Lorem ipsum dolor sit amet,consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. A list item with a blockquote: This is a blockquoteinside a list item. 代码（前面缩进）:tell application &quot;Foo&quot; beep end tell Use the printf() function. A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any haa tags. 分割线 链接Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： This is an example inline link. This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：1[id]: http://example.com/ &quot;Optional Title Here&quot;. 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址选择性地接着 title 内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： 12345 [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12 [link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调single asterisks single underscores double asterisks double underscores 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。参考式的图片语法则长得像这样： 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 z自动链接http://example.com/ &#97;&#100;&#100;&#114;&#x65;&#115;&#115;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d; 反斜杠插入特殊字符 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向工具]]></title>
    <url>%2F2018%2F02%2F07%2FiOS%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[iOS逆向常用的一些小工具 砸壳工具dumpdecrypted的使用 将~/HackTools/dumpdecrypted-master/dumpdecrypted.dylib拷贝到TargetApp的Documents目录下 开始砸壳 1DYLD_INSERT_LIBRARIES=/path/to/dumpdecrypted.dylib /path/to/executable class-dump的使用 在Terminal中进入App所在的目录，并用Xcode自带的plutil工具查看Info.plist中的“CFBundleExecutable”字段： 1plutil -p Info.plist | grep CFBundleExecutable 将头文件dump到指定文件夹下,且内容按名字排序 1class-dump -S -s -H 可执行文件 -o 文件夹]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案]]></title>
    <url>%2F2018%2F02%2F07%2FMac%E7%B3%BB%E7%BB%9F10-11%E4%B9%8B%E5%90%8E-usr-bin-%E6%8B%B7%E8%B4%9D%E6%9D%83%E9%99%90%E7%A6%81%E6%AD%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限是禁止的，此时自定义的基础功能二进制文件使用困难，以下是比较好的解决方案，亲测有效！ Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案 Step1：在当前用户根目录下创建一个bin目录； 命令：mkdir ~/bin Step2：把要拷贝 实现基础功能的二进制 如class-dump给拷贝到这个目录里，并赋予其可执行权限; 命令一: sudo cp /.../class-dump ~/bin (/…/class-dump是指的class-dump的完整路径) 命令二: chmod +x ~/bin/class-dump Step3：打开~/.bash_profile文件，配置环境变量 命令一: vi ~/.bash_profile 命令二: 按 i 键进入编辑模式，写入下面一行代码， export PATH=$HOME/bin/:$PATH 按ESC然后输入冒号(shift+;),然后输入wq,退出即可。 Step4：在Terminal中执行source命令(每次开机后都要重新source) 命令:source ~/.bash_profile完成以上步骤，在terminal中执行class-dump实验一下，应该就可以了。 其他方案：修改系统权限 关闭 Rootless。重启按住 Command+R，进入恢复模式，打开Terminal。 csrutil disable 重启即可。如果要恢复默认，那么 csrutil enable 附录: csrutil命令参数格式： csrutil enable [--without kext | fs | debug | dtrace | nvram][--no-internal] 禁用：csrutil disable （等同于csrutil enable --without kext --without fs --without debug --without dtrace --without nvram） 其中各个开关，意义如下： B0: [kext] 允许加载不受信任的kext（与已被废除的kext-dev-mode=1等效） B1: [fs] 解锁文件系统限制 B2: [debug] 允许task_for_pid()调用 B3: [n/a] 允许内核调试 （官方的csrutil工具无法设置此位） B4: [internal] Apple内部保留位（csrutil默认会设置此位，实际不会起作用。设置与否均可） B5: [dtrace] 解锁dtrace限制 B6: [nvram] 解锁NVRAM限制 B7: [n/a] 允许设备配置（新增，具体作用暂时未确定）]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lldb+debugserver速查表]]></title>
    <url>%2F2018%2F02%2F07%2Flldb-debugserver%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[lldb+debugserver是iOS逆向的一个重要的工具，用于动态调试，包括寻找有用api、寻找有用信息等等，结合IDA构成iOS逆向的大半江山。以下是我的速查表。 一、准备阶段 iPhone端开启监听123debugserver 192.168.3.242:8888 -a &quot;SpringBoard&quot;debugserver -x backboard 192.168.3.242:8888 /Applications/AppStore.app/AppStore lldb连接iPhone1process connect connect://192.168.3.235:8888 cycript连接123ps -e | grep /Applications(位置)查看当前可执行程序cycript -p 可执行程序 二、寻找思路 列出当前镜像1image list -o -f 列出调用栈信息12345thread backtracebt [all]sbt 找到view对应的controller123456首先找到view界面的地址（easy），通过调用[#0x17f92890 nextResponder]找到controller的名字通过lldb po [controller名 _ivarDescription]和[controller名 _shortMethodDescription]看方法和属性对方法和属性所在内存下断点读取寄存器信息，获取寄存器存放的对象 下断点(通过help br查看)1234567b functionbr s -a addressbr s -a ASLR+offset...... 调试下一步1234567891011121314151617181920212223br l（断点列表）br dis 序号（不加为全）br en 序号br del 序号c(下一个断点)s 源码级别单步执行，遇到子函数则进入si 单步执行，遇到子函数则进入n 源码级别单步执行，遇到子函数不进入，直接步过ni 单步执行，遇到子函数不进入，直接步过finish/f 退出子函数br com add 序号（执行这条命令后，LLDB会要求我们设置一系列指令，以“DONE”结束，） 寄存器12345reg r -a/-A...register read -a/-A...register write 寄存器 值 （将寄存器赋值）reg w 关于打印1234567891011121314151617181920212223242526po或p $寄存器 （打印寄存器的值）po [$寄存器 或类名 _shortMethodDescription]po [$寄存器 或类名 _ivarDescription]然后通过cycript进行调用，或者lldb本身可以调用：po [$寄存器 或类名 method]po [view subviews]po [view superviews]po [$r0（寄存器、地址） detailTextLabel]po [$r2 propertyForKey:@&quot;set&quot;]拿到setter方法po [$r2 propertyForKey:@&quot;get&quot;]拿到getter方法po[$r2 allTargets]拿到调用者，用于写在函数前面拿到了调用者也相当于拿到了类，可以用method或class-dump定位方法和属性，用ida定位方法，进入方法内部作进一步分析，结合lldb再做断点调试，看寄存器的method，看target和寄存器存放的形参。po [button allControlEvents]拿到部分形参[button actionsForTarget:#0x14609d00forControlEvent:64] 通过help ..查看详细 “函数的前4个参数存放在R0到R3中，其他参数存放在栈中；返回值放在R0中。” 12&gt; debugserver -x backboard 192.168.3.183:8888 /var/containers/Bundle/Application/A910BD37-4684-49A6-97A7-924891F98D90/WYParking.app/WYParking&gt;]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cuckoo沙箱问题列表]]></title>
    <url>%2F2018%2F01%2F10%2Fcuckoo%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言cuckoo sandbox是近年来一款非常好的动态检测开源工具，然而最新版本不支持py3，对中文不友好等问题凸显，以下是使用cuckoo沙箱遇到的问题汇总 解决中文适配问题 如下文件需指定编码 : #coding:utf-8 .cuckoo-&gt;analyzer-&gt;windows-&gt;analyzer.py .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;[all] .cuckoo-&gt;analyzer-&gt;windows-&gt;modules-&gt;packages-&gt;[all] 其他涉及打印、日志、执行包含中文路径文件 如下文件修改： .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py中 path = path.decode(&#39;utf-8&#39;) .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;human.py中指定需要识别中文 其他涉及打印、日志、执行包含中文路径文件中中文字符串 sudo cuckoo submit --package sp -o path=&quot;C://Program Files//Notepad加加//notepad++.exe&quot; test.bat其他 mongodb在重启后，需要重新建立启动文件夹 sudo rm -rf /data sudo mkdir -p /data/db sudo mongod (另一终端)sudo mongo]]></content>
      <categories>
        <category>PC应用检测</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Python</tag>
        <tag>cuckoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳辅助(转)]]></title>
    <url>%2F2018%2F01%2F10%2F%EF%BC%88%E8%BD%AC%EF%BC%89%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[教你用 Python 来玩微信跳一跳游戏模式2017 年 12 月 28 日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 DEMO「跳一跳」。这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。分数越高，那么在好友排行榜更加靠前。通过 Python 脚本自动运行，让你轻松霸榜。 可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。如果能利用图像识别精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃。 原理说明 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 12adb shell screencap -p /sdcard/autojump.pngadb pull /sdcard/autojump.png . 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳 1adb shell input swipe x y x y time(ms) 使用教程 方法 1：使用 app 进行一键操作。目前已适配 Win10 64位/macOS 平台 Android 一键操作，下载请移步 STOP_jump 方法 2：相关软件工具安装和使用步骤请参考 Android 和 iOS 操作步骤 FAQ 详见 Wiki-FAQ 更新日志 详见 changelog 开发者列表 详见 contributors QQ 交流 314659953 (1000人 已满) 176740763 (500人 已满) 89213434 (2000人 已满) 64389940 (2000人)]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Games</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CppPrimer5_ch01_answers]]></title>
    <url>%2F2018%2F01%2F08%2FCppPrimer5-ch01-answers%2F</url>
    <content type="text"><![CDATA[前言《CppPrimer5》第一章课后答案 Exercise 1.1 Review the documentation for your compiler and determine what file naming convention it uses. Compile and run the main program from page 2. Windows Linux Exercise 1.2 Exercise 1.2: Change the program to return -1. A return value of -1 is often treated as an indicator that the program failed. Recompile and rerun your program to see how your system treats a failure indicator from main. Windows Linux 255? why? please look at this Exercise 1.3 Write a program to print Hello, World on the standard output. 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello, World" &lt;&lt; std::endl; return 0;&#125; Exercise 1.4 Our program used the addition operator, +, to add two numbers. Write a program that uses the multiplication operator, *, to print the product instead. 1234567891011#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 * v2 &lt;&lt; std::endl; return 0;&#125; Exercise 1.5 We wrote the output in one large statement. Rewrite the program to use a separate statement to print each operand. 12345678910111213141516#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of "; std::cout &lt;&lt; v1; std::cout &lt;&lt; " and "; std::cout &lt;&lt; v2; std::cout &lt;&lt; " is "; std::cout &lt;&lt; v1 * v2; std::cout &lt;&lt; std::endl; return 0;&#125; Exercise 1.6 Explain whether the following program fragment is legal. It’s illegal. [Error] expected primary-expression before ‘&lt;&lt;’ token Fixed it: remove the spare semicolons. 123std::cout &lt;&lt; "The sum of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 + v2 &lt;&lt; std::endl; Exercise 1.7 Compile a program that has incorrectly nested comments. Example:123456789/** comment pairs /* */ cannot nest.* ''cannot nest'' is considered source code,* as is the rest of the program*/int main()&#123; return 0;&#125; Compiled result(g++): Exercise 1.8 Indicate which, if any, of the following output statements are legal:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */;std::cout &lt;&lt; /* "*/" /* "/*" */; After you’ve predicted what will happen, test your answers by compiling aprogram with each of these statements. Correct any errors you encounter. Compiled result(g++): Corrected? just added a quote:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */";std::cout &lt;&lt; /* "*/" /* "/*" */; Output: /**/ */ /* Exercise 1.9Exercise 1.10Exercise 1.11Exercise 1.12 What does the following for loop do? What is the final valueof sum?123int sum = 0;for (int i = -100; i &lt;= 100; ++i)sum += i; the loop sums the numbers from -100 to 100. the final value of sum is zero. Exercise 1.13 Rewrite the exercises from § 1.4.1 (p. 13) using for loops. Ex1.9:123456789101112#include &lt;iostream&gt;int main()&#123; int sum = 0; for (int i=50; i&lt;=100; ++i) sum += i; std::cout &lt;&lt; "the sum is: " &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; Ex1.10:123456789#include &lt;iostream&gt;int main()&#123; for (int i=10; i&gt;=0; --i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Ex1.11:1234567891011121314151617181920#include &lt;iostream&gt;int main()&#123; int val_small = 0, val_big = 0; std::cout &lt;&lt; "please input two integers:"; std::cin &gt;&gt; val_small &gt;&gt; val_big; if (val_small &gt; val_big) &#123; int tmp = val_small; val_small = val_big; val_big = tmp; &#125; for (int i=val_small; i&lt;=val_big; ++i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Exercise 1.14 Compare and contrast the loops that used a for with thoseusing a while. Are there advantages or disadvantages to using either form? If you need a pattern which is using a variable in a condition and incrementing that variable in thebody. You should use for loop. Else the while loop is more simple. Want to know more? look at this Exercise 1.15 Write programs that contain the common errors discussed inthe box on page 16. Familiarize yourself with the messages the compilergenerates. JUST READ IT! Exercise 1.16 Write your own version of a program that prints the sum of a set of integers read from cin. Many people confused about this exercise, such as this and this. In my opinion, the exercise aim to write the program without “END-OF-FILE“. BUT, the code in first link is not correct. The following are my own version: 12345678910111213141516#include &lt;iostream&gt;int main()&#123; int limit = 0, sum = 0, value = 0; std::cout &lt;&lt; "How many integers would you like to enter?"; std::cin &gt;&gt; limit; // assume we don't know what is EOF(End-Of-File). while (std::cin &gt;&gt; value &amp;&amp; (--limit != 0)) sum += value; std::cout &lt;&lt; sum + value &lt;&lt; std::endl; return 0;&#125; Watch out for “sum + value” in the cout line. Exercise 1.17 What happens in the program presented in this section if the input values are all equal? What if there are no duplicated values? If the input values are all equal, it will print a line which shows the count of the number you input. If there are no duplicated values, when different values input, a new line will be printed if you click Enter. Exercise 1.18 Compile and run the program from this section giving it only equal values as input. Run it again giving it values in which no number is repeated. Exercise 1.19 Revise the program you wrote for the exercises in § 1.4.1 (p. 13) that printed a range of numbers so that it handles input in which the first number is smaller than the second. Yes, we should use if to judge which is bigger. review this code Exercise 1.20 http://www.informit.com/title/032174113 contains a copy of Sales_item.h in the Chapter 1 code directory. Copy that file to your working directory. Use it to write a program that reads a set of book sales transactions, writing each transaction to the standard output. Here is the code. You need to enable C++11 support in your compiler.With GCC and Clang, this can be done with the -std=c++11 option. (Never say it again.) How to test it? use the book.txt in data folder. And do it like this: Exercise 1.21 Write a program that reads two Sales_item objects that have the same ISBN and produces their sum. The program should check whether the objects have the same ISBN.(Have a look at 1.5.2, surprise!) Code Exercise 1.22 Write a program that reads several transactions for the same ISBN. Write the sum of all the transactions that were read. Tips: this program will appear in the section 1.6. Here is the code. Exercise 1.23 Write a program that reads several transactions and countshow many transactions occur for each ISBN. Tip: please review the 1.4.4. Here is the code. Exercise 1.24 Test the previous program by giving multiple transactionsrepresenting multiple ISBNs. The records for each ISBN should be groupedtogether. You can use data/book.txt as the records. Exercise 1.25 Using the Sales_item.h header from the Web site,compile and execute the bookstore program presented in this section. It is the same as Exercise 1.22.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blah blah blah Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Guide</tag>
      </tags>
  </entry>
</search>
