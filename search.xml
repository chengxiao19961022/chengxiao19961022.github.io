<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[倒水问题fill-UVa 10603]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98fill-UVa-10603%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目 测试输入1 1 12 15 7 测试输出14 7 HINTbfs+prioqueue,队列扩展优先总倒水量小的 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int maxn = 200 + 5;struct WaterNode&#123; int v[3]; int dist; WaterNode ():dist(0)&#123;&#125; bool operator &lt; (const WaterNode&amp; rhs) const&#123; return dist &gt; rhs.dist; &#125;&#125;;int ans[maxn];// ans[d]表示得到d升水的最小水量int cap[3];// 每杯水的容量int book[maxn][maxn];void updateAns(const WaterNode&amp; n)&#123; for (int i = 0; i &lt; 3; ++i) &#123; if (ans[n.v[i]] &lt; 0 || ans[n.v[i]] &gt; n.dist) ans[n.v[i]] = n.dist; &#125;&#125;void bfs(int a, int b, int c, int d)&#123; cap[0] = a;cap[1] = b;cap[2] = c; memset(book, 0, sizeof(book)); memset(ans, -1, sizeof(ans)); priority_queue&lt;WaterNode&gt; waterQueue; WaterNode start; start.v[0] = 0; start.v[1] = 0; start.v[2] = c; waterQueue.push(start); book[0][0] = 1; while(!waterQueue.empty())&#123; WaterNode fro = waterQueue.top(); // 更新ans updateAns(fro); if(ans[d] &gt;= 0) break; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; if (i != j)&#123; // i往j倒水 if (fro.v[i] == 0 || fro.v[j] == cap[j]) continue; WaterNode nextNode; memcpy(nextNode.v, fro.v, sizeof(fro.v)); int amount = min(cap[j], fro.v[i]+fro.v[j]) - fro.v[j]; nextNode.v[i] -= amount; nextNode.v[j] += amount; nextNode.dist = fro.dist + amount; if (!book[nextNode.v[i]][nextNode.v[j]])&#123; book[nextNode.v[i]][nextNode.v[j]] = 1; waterQueue.push(nextNode); &#125; &#125; &#125; &#125; waterQueue.pop(); &#125; while (d&gt;=0)&#123; if(ans[d] &gt;= 0) &#123; printf("%d %d\n", ans[d], d); return; &#125; d--; &#125;&#125;int main( ) &#123; int T, a, b, c, d; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); bfs(a, b, c, d); &#125; return 0;&#125; 总结bfs求最短路径]]></content>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八数码问题]]></title>
    <url>%2F2018%2F04%2F14%2F%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目编号为1～8的8个正方形滑块被摆成3行3列（有一个格子留空），如图7-14所示。每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原来的位置就成为了新的空格。给定初始局面和目标局面（用0表示空格），你的任务是计算出最少的移动步数。如果无法到达目标局面，则输出-1。 样例输入2 6 4 1 3 7 0 5 8 8 1 5 7 3 6 4 0 2 样例输出31 HINT采用BFS求解，每次保存整体状态而非坐标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169typedef int State[9]; //定义"状态"类型const int maxstate = 1000000;State st[maxstate], goal; //状态数组。所有状态都保存在这里int dist[maxstate]; //距离数组//如果需要打印方案，可以在这里加一个"父亲编号"数组 int fa[maxstate]const int dx[ ] = &#123;-1, 1, 0, 0&#125;;const int dy[ ] = &#123;0, 0, -1, 1&#125;;//hash表存放状态，因为0-8的排列最多为9!=362880个const int hashsize = 1000003;int head[hashsize], next1[maxstate];void init_lookup_table( ) &#123; memset(head, 0, sizeof(head)); &#125;int hash1(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把9个数字组合成9位数 return v % hashsize; //确保hash函数值是不超过hash表的大小的非负整数&#125;int try_to_insert(int s)&#123; int h = hash1(st[s]); int u = head[h]; //从表头开始查找链表 while(u)&#123; if(memcmp(st[u],st[s], sizeof(st[s]))==0) return 0; //找到了，插入失败，book=1 u = next1[u]; //顺着链表继续找 &#125; next1[s] = head[h]; //插入到链表中 head[h] = s; return 1;//book=0&#125;//BFS，返回目标状态在st数组下标int bfs( ) &#123; init_lookup_table( ); //初始化查找表,用于去重 int front = 1, rear = 2; //不使用下标0，因为0被看作"不存在" while(front&lt; rear) &#123; State&amp; s = st[front]; if(memcmp(goal, s, sizeof(s)) == 0) return front;//找到目标状态，成功返回 int z; for(z = 0; z &lt; 9; z++) if(!s[z]) break; //找"0"的位置 int x = z/3, y = z%3; //获取行列编号（0~2） for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if(newx &gt;= 0 &amp;&amp; newx &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3)&#123; //如果移动合法 State&amp; t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); //扩展新结点 t[newz] = s[z]; t[z] = s[newz]; dist[rear] = dist[front] + 1; //更新新结点的距离值 if(try_to_insert(rear)) rear++; //如果成功插入查找表，修改队尾指针 &#125; &#125; front++; //扩展完毕后再修改队首指针 &#125; return 0; //失败&#125;int main( )&#123; for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;st[1][i]); //起始状态 for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;goal[i]); //目标状态 int ans = bfs( ); //返回目标状态的下标 if(ans &gt; 0) printf("%d\n", dist[ans]); else printf("-1\n"); return 0;&#125;//封装typedef int State[9]; //定义"状态"类型const int maxstate = 1000000;struct StateNode&#123; StateNode():dist(0)&#123;&#125; State stat; int dist;&#125;;State goal; //状态数组。所有状态都保存在这里//如果需要打印方案，可以在这里加一个"父亲编号"数组 int fa[maxstate]const int dx[ ] = &#123;-1, 1, 0, 0&#125;;const int dy[ ] = &#123;0, 0, -1, 1&#125;;//hash表存放状态，因为0-8的排列最多为9!=362880个const int hashsize = 1000003;struct HashNode&#123; HashNode():next(0)&#123;&#125; State stat; HashNode* next;&#125;;HashNode* head[hashsize];void init_lookup_table( ) &#123; memset(head, 0, sizeof(head)); &#125;int hash1(State s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把9个数字组合成9位数 return v % hashsize; //确保hash函数值是不超过hash表的大小的非负整数&#125;int try_to_insert(StateNode s)&#123; int h = hash1(s.stat); HashNode* u = head[h]; //从表头开始查找链表 while(u)&#123; if(memcmp(u-&gt;stat,s.stat, sizeof(s.stat))==0) return 0; //找到了，插入失败，book=1 u = u-&gt;next; //顺着链表继续找 &#125; HashNode* n = new HashNode(); memcpy(&amp;n-&gt;stat, &amp;s.stat, sizeof(s.stat)); n-&gt;next = head[h]; head[h] = n; return 1;//book=0&#125;void deleteHash(HashNode* h[])&#123; for(int i = 0; i &lt; hashsize; ++i)&#123; if(!h[i]) continue; HashNode* cur = h[i]; while(cur)&#123; HashNode* de = cur; cur = cur-&gt;next; delete de; &#125; &#125;&#125;//BFS，返回目标状态在st数组下标int bfs(StateNode be) &#123; init_lookup_table( ); //初始化查找表,用于去重 queue&lt;StateNode&gt; StatQueue; StatQueue.push(be); while(!StatQueue.empty()) &#123; StateNode&amp; s = StatQueue.front(); if(memcmp(goal, s.stat, sizeof(s.stat)) == 0) return s.dist;//找到目标状态，成功返回 int z; for(z = 0; z &lt; 9; z++) if(!s.stat[z]) break; //找"0"的位置 int x = z/3, y = z%3; //获取行列编号（0~2） for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if(newx &gt;= 0 &amp;&amp; newx &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3)&#123; //如果移动合法 StateNode t; memcpy(&amp;t.stat, &amp;s.stat, sizeof(s.stat)); //扩展新结点 t.stat[newz] = s.stat[z]; t.stat[z] = s.stat[newz]; t.dist = s.dist+1; //更新新结点的距离值 if(try_to_insert(t)) StatQueue.push(t); //如果成功插入查找表，修改队尾指针 &#125; &#125; StatQueue.pop(); //扩展完毕后再修改队首指针 &#125; return 0; //失败&#125;int main( )&#123; StateNode sta; for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;sta.stat[i]); //起始状态 for(int i = 0; i &lt; 9; i++) scanf("%d", &amp;goal[i]); //目标状态 int ans = bfs(sta); //返回目标状态的下标 if(ans &gt; 0) printf("%d\n", ans); else printf("-1\n"); deleteHash(head); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治-棋盘覆盖问题]]></title>
    <url>%2F2018%2F04%2F11%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 转自:分治法——棋盘覆盖问题 题目棋盘覆盖问题。有一个2k∗2k的方格棋盘，恰有一个方格是黑色的，其他为白色。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。如图所示为L型牌的4种旋转方式。 HINT分治三步骤划分问题：将2k∗2k的棋盘划分为2k−1∗2k−1这样的子棋盘4块。 递归求解：递归填充各个格子，填充分为四个情况，在下面会有解释，递归出口为k=0也就是子棋盘方格数为1。 合并问题：不需要合并子问题。 递归填充的四种情况如果黑方块在左上子棋盘，则递归填充左上子棋盘；否则填充左上子棋盘的右下角，将右下角看做黑色方块，然后递归填充左上子棋盘。 如果黑方块在右上子棋盘，则递归填充右上子棋盘；否则填充右上子棋盘的左下角，将左下角看做黑色方块，然后递归填充右上子棋盘。 如果黑方块在左下子棋盘，则递归填充左下子棋盘；否则填充左下子棋盘的右上角，将右上角看做黑色方块，然后递归填充左下子棋盘。 如果黑方块在右下子棋盘，则递归填充右下子棋盘；否则填充右下子棋盘的右下角，将左上角看做黑色方块，然后递归填充右下子棋盘。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;const int maxNum = 1 &lt;&lt; 10;// 棋盘int chess[maxNum][maxNum];// L型牌编号int number;void chessBoard(int row, int column, int x, int y, int siz) &#123; // 递归出口 if(siz == 1) &#123; return; &#125; // 对半划分成2^(siz - 1) * 2^(siz - 1)的棋盘 int s = siz / 2; // L型牌编号自增 int t = ++number; // 中间点，以此判别(x,y)在哪个子棋盘中 int centerRow = row + s; int centerColumn = column + s; // 黑色方格在左上子棋盘 if(x &lt; centerRow &amp;&amp; y &lt; centerColumn) &#123; chessBoard(row, column, x, y, s); &#125; else &#123; // 不在则填充左上子棋盘的右下角 chess[centerRow - 1][centerColumn - 1] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(row, column, centerRow - 1, centerColumn - 1, s); &#125; // 黑色方格在右上子棋盘 if(x &lt; centerRow &amp;&amp; y &gt;= centerColumn) &#123; chessBoard(row, centerColumn, x, y, s); &#125; else &#123; // 不在则填充右上子棋盘的左下角 chess[centerRow - 1][centerColumn] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(row, centerColumn, centerRow - 1, centerColumn, s); &#125; // 黑色方格在左下子棋盘 if(x &gt;= centerRow &amp;&amp; y &lt; centerColumn) &#123; chessBoard(centerRow, column, x, y, s); &#125; else &#123; // 不在则填充左下子棋盘的右上角 chess[centerRow][centerColumn - 1] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(centerRow, column, centerRow, centerColumn - 1, s); &#125; // 黑色方格在右下子棋盘 if(x &gt;= centerRow &amp;&amp; y &gt;= centerColumn) &#123; chessBoard(centerRow, centerColumn, x, y, s); &#125; else &#123; // 不在则填充右下子棋盘的左上角 chess[centerRow][centerColumn] = t; // 然后覆盖其他格子，注意这时(x,y)要看做已填充位置 chessBoard(centerRow, centerColumn, centerRow, centerColumn, s); &#125;&#125;int main() &#123; // 大小，黑色方格位置 int siz, x, y; while(true) &#123; cout &lt;&lt; "(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。" &lt;&lt; endl; cout &lt;&lt; "请输入棋盘大小和黑色方格位置(x,y)："; cin &gt;&gt; siz &gt;&gt; x &gt;&gt; y; // 退出条件 if(siz == 0) &#123; break; &#125; // 涂黑(x,y)，初始化L型牌编号 chess[x][y] = number = 1; // 分治法填满棋盘 chessBoard(0, 0, x, y, siz); // 输出该棋盘 for(int i = 0; i &lt; siz; i++) &#123; for(int j = 0; j &lt; siz; j++) &#123; cout &lt;&lt; chess[i][j] &lt;&lt; "\t"; &#125; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; &#125; &#125; return 0;&#125; 测试输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：2 0 01 22 2(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：4 1 13 3 4 43 1 2 45 2 2 65 5 6 6(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：8 2 24 4 5 5 9 9 10 104 3 3 5 9 8 8 106 3 1 7 11 11 8 126 6 7 7 2 11 12 1214 14 15 2 2 19 20 2014 13 15 15 19 19 18 2016 13 13 17 21 18 18 2216 16 17 17 21 21 22 22(x,y)从(0,0)开始,输入数据为0 0 0即结束程序。请输入棋盘大小和黑色方格位置(x,y)：0 0 0Process returned 0 (0x0) execution time : 29.988 sPress any key to continue. 总结]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa806 习题6-8 空间结构（Spatial Structures,ACM/ICPC World Finals 1998）]]></title>
    <url>%2F2018%2F04%2F10%2FUVa806-%E4%B9%A0%E9%A2%986-8-%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%EF%BC%88Spatial-Structures-ACM-ICPC-World-Finals-1998%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目黑白图像有两种表示法：点阵表示和路径表示。路径表示法首先需要把图像转化为四分 树，然后记录所有黑结点到根的路径。例如，对于如图6-25所示的图像。 四分树如图6-26所示。 NW、NE、SW、SE分别用1、2、3、4表示。最后把得到的数字串看成是五进制的，转 化为十进制后排序。例如上面的树在转化、排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。你的任务是在这两种表示法之间进行转换。在点阵表示法中，1表示黑色，0表示白色。图像总是正方形的，且长度n为2的整数幂，并满足n≤64。输入输出细节请参见原题。 HINT代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;valarray&gt;#include &lt;vector&gt;using namespace std;#define _for(i, a, b) for (int i = (a); i &lt; (b); ++i)#define _rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)typedef long long LL;/* NW = 1, NE = 2, SW = 3, SE = 4 */const int MAXN = 64 + 4, DX[] = &#123;0, 0, 1, 1&#125;, DY[] = &#123;0, 1, 0, 1&#125;;int N;char IMG[MAXN][MAXN];void countBlack(int x, int y, int len, vector&lt;int&gt;&amp; ans, int path = 0, int p5 = 1) &#123; int f = 0, len2 = len / 2; _for(i, x, x + len) _for(j, y, y + len) f += IMG[i][j] - '0'; if (f == 0) return; if (f == len * len) &#123; ans.push_back(path); return; &#125; _for(di, 0, 4) countBlack(x+DX[di]*len2, y+DY[di]*len2, len2, ans, path+p5*(di+1), p5*5);&#125;void draw(int path, int x, int y, int len) &#123; if (path == 0) &#123; assert(len); _for(i, x, x + len) _for(j, y, y + len) IMG[i][j] = '*'; return; &#125; int di = path % 5 - 1, len2 = len / 2; draw(path / 5, x + DX[di] * len2, y + DY[di] * len2, len2);&#125;int main() &#123; for (int kase = 1; scanf("%d", &amp;N) == 1 &amp;&amp; N; kase++) &#123; if (kase &gt; 1) puts(""); printf("Image %d\n", kase); if (N &gt; 0) &#123; _for(i, 0, N) scanf("%s", IMG[i]); vector&lt;int&gt; blacks; countBlack(0, 0, N, blacks); sort(begin(blacks), end(blacks)); int sz = blacks.size(); _for(i, 0, sz) printf("%d%s", blacks[i], (i % 12 == 11 || i == sz - 1) ? "\n" : " "); printf("Total number of black nodes = %d\n", sz); &#125; else &#123; int p; memset(IMG, 0, sizeof(IMG)); N = -N; _for(i, 0, N) _for(j, 0, N) IMG[i][j] = '.'; while (scanf("%d", &amp;p) == 1 &amp;&amp; p &gt;= 0) draw(p, 0, 0, N); _for(i, 0, N) puts(IMG[i]); &#125; &#125; return 0;&#125; 总结]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 804 - Petri Net Simulation（模拟）]]></title>
    <url>%2F2018%2F04%2F10%2FUVa-804-Petri-Net-Simulation%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 题目描述你的任务是模拟Petri网的变迁。Petri网包含NP个库所（用P1，P2…表示）和NT个变迁 （用T1，T2…表示）。0&lt;NP, NT&lt;100。当每个变迁的每个输入库所都至少有一个token时， 变迁是允许的。变迁发生的结果是每个输入库所减少一个token，每个输出库所增加一个 token。变迁的发生是原子性的，即所有token的增加和减少应同时进行。注意，一个变迁可 能有多个相同的输入或者输出。如果一个库所在变迁的输入库所列表中出现了两次，则token 会减少两个。输出库所也是类似。如果有多个变迁是允许的，一次只能发生一个。如图6-24所示，一开始只有T1是允许的，发生一次T1变迁之后有一个token会从P1移动到P2，但仍然只有T1是允许的，因为T2要求P2有两个token。再发生一次T1变迁之后P1中只 剩一个token，而P2中有两个，因为T1和T2都可以发生。假定T2发生，则P2中不再有token，而P3中有一个token，因此T1和T3都是允许的。 HINT输入一个Petri网络。初始时每个库所都有一个token。每个变迁用一个整数序列表示，负 数表示输入库所，正数表示输出库所。每个变迁至少包含一个输入和一个输出。最后输入一 个整数NF，表示要发生NF次变迁（同时有多个变迁允许时可以任选一个发生，输入保证这个选择不会影响最终结果）。 依次对每个T(i)进行执行，如果每个input都能执行成功（NP中有token）则执行，则执行output，并将执行T(i)的次数++，否则恢复刚才所有执行的input。一轮（将所有T(i)执行一遍）中任意一个T(i)执行就可以执行下一轮。如果一轮中没有任何一个T(i)执行成功则说明执行失败，返回执行次数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int deal();const int MAXN = 100 + 10;int NP[MAXN]; //P(i)现存小球的数量int NT_in[MAXN][MAXN]; //存储T(i)的inputint NT_out[MAXN][MAXN]; //存储T(i)的outputint n, m, num;int main()&#123; int kase = 0; while (cin &gt;&gt; n &amp;&amp; n) &#123; //初始化 memset(NT_in,0,sizeof(NT_in)); memset(NT_out, 0, sizeof(NT_out)); int k,i, j, x, do_num; for (i = 1; i &lt;= n; i++) cin &gt;&gt; NP[i]; cin &gt;&gt; m; for (i = 0; i &lt; m; i++)&#123; k = j = 0; while (cin &gt;&gt; x &amp;&amp; x)&#123; if (x &lt; 0) NT_in[i][j++] = x; else NT_out[i][k++] = x; &#125; &#125; cin &gt;&gt; num; //处理 do_num = deal(); //处理函数，返回执行变迁的次数 //输出 if(do_num == num) cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": still live after " &lt;&lt; do_num &lt;&lt; " transitions\n"; else cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": dead after " &lt;&lt; do_num &lt;&lt; " transitions\n"; cout &lt;&lt; "Places with tokens:"; for (int i = 1; i &lt;= n; i++) //逐个输出有token的P,和个数 if (NP[i] &gt; 0) cout &lt;&lt; " " &lt;&lt; i &lt;&lt; " (" &lt;&lt; NP[i] &lt;&lt; ")"; cout &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125;/*依次对每个T(i)进行执行，如果每个input都能执行成功（NP中有token）则执行，则执行output，并将执行T(i)的次数++，否则恢复刚才所有执行的input。一轮（将所有T(i)执行一遍）中任意一个T(i)执行就可以执行下一轮。如果一轮中没有任何一个T(i)执行成功则说明执行失败，返回执行次数。*/int deal()&#123; int i, j, n = 1; while(1) &#123; bool had_do = false; //该轮中有T(i)执行，可以执行下一轮 for (i = 0; i &lt; m; i++)&#123; j = 0; bool can_do = true;//该T(i)执行是否成功 while (NT_in[i][j] != 0)&#123; if (NP[-NT_in[i][j]] &gt; 0) //执行input NP[-NT_in[i][j++]]--; else&#123; //input执行失败，恢复input之前状态，并将can_do置为false while (j--) NP[-NT_in[i][j]]++; can_do = false; break; &#125; &#125; if (can_do) &#123; //input执行成功的情况下执行output j = 0; n++;//*** while (NT_out[i][j] != 0)&#123; NP[NT_out[i][j]]++; j++; &#125; had_do = true; if (n &gt; num) return num; &#125; else break; &#125; if (!had_do) return n-1; &#125;&#125; 总结重点在于理解题意]]></content>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim基本使用]]></title>
    <url>%2F2018%2F03%2F23%2Fvim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vim的基本使用 Vim键盘分布图 Vim树状图]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法小计（每日更新）]]></title>
    <url>%2F2018%2F03%2F20%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%A1%EF%BC%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天坚持做算法题，熟悉基本的套路，巩固语言基础，总结经验记下所学所想。 2018-3-20P60近似计算123456789101112131415161718#include &lt;math.h&gt;int main()&#123; int i = 0; double sum = 0; double term; do&#123; term = 1.0/(2*i+1);//注意写成1.0而不是1 sum+=pow(-1,i)*term; ++i; &#125;while(term&gt;=pow(10, -6)); cout&lt;&lt;sum; return 0;&#125; P62阶乘之和 要计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在每步计算之后对n取余，结果不变。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;time.h&gt;int main()&#123; const int MOD = 1000000; int n, S = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; int factorial = 1; for(int j = 1; j &lt;= i; j++) factorial = (factorial * j % MOD); S = (S + factorial) % MOD; &#125; printf("%d\n", S); printf("Time used = %.2f\n", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; P94键盘输入12345678910111213141516string s = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";// 这里s为47个char，s[47] = nullint main() &#123; int i, c; while((c = getchar())!=EOF)&#123; for (i = 1; s[i]&amp;&amp;s[i]!=c ; ++i); if (s[i])//如果找不到 s[47] = null putchar(s[i-1]); else putchar(c); &#125; return 0;&#125; 2018-3-21P140刽子手 关键在于设立win和lose以及bad的标志位，没猜一个更新标志位 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 100int left, chance; //还需要猜left个位置,错chance次之后就会输char s[maxn], s2[maxn]; //答案是字符串s,玩家猜的字母序列是s2int win, lose; //win=1表示已经赢了;lose=1表示已经输了void guess(char ch) ;int main() &#123; int rnd; while(scanf("%d%s%s", &amp;rnd, s, s2) == 3 &amp;&amp; rnd != -1) &#123; printf("Round %d\n", rnd); win = lose = 0; //求解一组新数据之前要初始化 left = strlen(s); chance =7; for(int i = 0; i &lt; strlen(s2); i++) &#123; guess(s2[i]); //猜一个字母 if(win || lose) break; //检查状态 &#125; //根据结果进行输出 if(win) printf("You win.\n"); else if(lose) printf("You lose.\n"); else printf("You chickened out.\n"); &#125; return 0;&#125;void guess(char ch) &#123; int bad = 1; for(int i = 0; i &lt; strlen(s); i++) if(s[i] == ch) &#123; left--; s[i] = ' '; bad = 0; &#125; if(bad) --chance; if(!chance) lose = 1; if(!left) win = 1;&#125; P145信息编码 使用char code[n][1&lt;&lt;n]存放编码本，n。前面的n表示二进制长度，后面的表示该二进制数的十进制表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;string.h&gt; //使用memsetint readchar() ;int readint(int c) ;int code[8][1&lt;&lt;8];int readcodes() ;int main() &#123; while(readcodes()) &#123; //无法读取更多编码头时退出//printcodes(); for(;;) &#123; int len = readint(3); if(len == 0) break;//printf("len=%d\n", len); for(;;) &#123; int v = readint(len);//printf("printf("v=%d\n", v); if(v == (1 &lt;&lt; len)-1) break; putchar(code[len][v]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;int readchar() &#123; for(;;) &#123; int ch = getchar(); if(ch != '\n' &amp;&amp; ch != '\r') return ch; //一直读到非换行符为止 &#125;&#125;int readint(int c) &#123; int v = 0; while(c--) v = v * 2 + readchar() - '0'; return v;&#125;// 生成编码本int readcodes() &#123; memset(code, 0, sizeof(code)); //清空数组 code[1][0] = readchar(); //直接调到下一行开始读取。如果输入已经结束，会读到EOF for(int len = 2; len &lt;= 7; len++) &#123; for(int i = 0; i &lt; (1&lt;&lt;len)-1; i++) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\n' || ch == '\r') return 1; code[len][i] = ch; &#125; &#125; return 1;&#125; 2018-3-24北邮OJ-11网研第三题-中序遍历树题目描述给一棵树，你可以把其中任意一个节点作为根节点。每个节点都有一个小写字母，中序遍历，得到一个字符串，求所有能得到的字符串的字典序最小串。因为这棵树不一定是二叉树，所以中序遍历时，先中序遍历以节点序号最小的节点为根的子树，然后再遍历根节点，最后根据节点序号从小到大依次中序遍历剩下的子树。 HINT意思就是请枚举所有的点为根，然后中序遍历最后输出所有结果中字典序最小的比如说第二组数据以0为根时结果为 bacd以1为根时结果为 cadb 以2为根时结果为 badc以3为根时结果为 bacd所以字典序最小的是bacd 输入格式多组数据，以EOF结束。 第一行一个数n（0&lt; n &lt; =100）,表示树的节点的个数，节点从0开始。 然后一个长度为n的串，第i（0&lt; = i &lt; n）个字符表示节点i的字符。接下来n-1行，每行两个数a，b,(0&lt; = a,b &lt; n),表示a和b之间有一条无向边。 输出格式题中要求的最小的字符串 输入样例3 bac 0 1 1 2 4 abcd 0 1 0 2 0 3 输出样例bac bacd 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;char func[101];bool relation[100][100]=&#123;false&#125;;bool visited[100]=&#123;false&#125;;string result;string temp;void dfs(int pos,int n)&#123; int son[100]; int size=0; visited[pos]=true; for(int j=0;j&lt;n;j++) &#123;// if(j==pos)continue; if(relation[pos][j]==true&amp;&amp;!visited[j]) &#123; son[size++]=j; &#125; &#125; if(size&gt;0) &#123; dfs(son[0],n); temp+=func[pos]; for(int j=1;j&lt;size;j++) &#123; dfs(son[j],n); &#125; &#125; else if(size==0)temp+=func[pos];&#125;int main()&#123; int n,a,b,t; while(cin&gt;&gt;n) &#123; result=""; temp=""; cin&gt;&gt;func; t=n; t--; memset(relation,0,sizeof(relation)); //cout&lt;&lt;relation[99][99]; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; relation[a][b]=true; relation[b][a]=true; &#125; int it=-1; for(int i=0;i&lt;n;i++) &#123; memset(visited,0,sizeof(visited)); dfs(i,n); // cout&lt;&lt;"以"&lt;&lt;i&lt;&lt;"("&lt;&lt;func[i]&lt;&lt;")"&lt;&lt;"为根"&lt;&lt;temp&lt;&lt;endl; if(i==0)&#123; result=temp;it=i;&#125; else if(result&gt;temp)&#123; result=temp;it=i;&#125; temp=""; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125;&#125; 2018-3-25P186反片语HINT这里的map用于统计字符串的数量，如果出现两次则不输出。注意此时的key应该是标准化的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;string lowerstr(const string&amp; s)&#123; string ss = s; for (auto it = ss.begin(); it != ss.end() ; ++it) &#123; *it = tolower(*it); &#125; sort(ss.begin(), ss.end());// 核心 return ss;&#125;int main()&#123; vector&lt;string&gt; strvec; map&lt;string, int&gt; strmap; string str; while(cin&gt;&gt;str)&#123; if (str[0] == '#') break; strvec.push_back(str); string strlower = lowerstr(str); if (!strmap.count(strlower)) strmap[strlower] = 0; ++strmap[strlower]; &#125; vector&lt;string&gt; vec; for (auto it = strvec.begin(); it != strvec.end() ; ++it) &#123; if (strmap[lowerstr(*it)] == 1) vec.push_back(*it); &#125; sort(vec.begin(), vec.end()); for (int i = 0; i &lt; vec.size(); ++i) &#123; cout&lt;&lt;vec[i]&lt;&lt;endl; &#125;&#125; p189集合栈HINT使用vector存放集合，并把其和其在vector中的下标映射成map（因为ID是唯一的，避免每次查找vector使用map），stack中只需要存ID 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define ALL(x) x.begin(),x.end()#define INS(x) inserter(x,x.begin())typedef set&lt;int&gt; Set;vector&lt;Set&gt; vec;map&lt;Set, int&gt; smap;int ID(Set s)&#123; if (smap.count(s)) return smap[s]; vec.push_back(s); return smap[s] = vec.size() - 1;&#125;int main()&#123; string cmd; stack&lt;int&gt; st; int n; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;cmd; Set x = Set(); int s1,s2; switch (cmd[0]) &#123; case 'P': st.push(ID(Set())); break; case 'D': st.push(st.top()); break; case 'U': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); set_union(ALL(vec[s1]), ALL(vec[s2]), INS(x)); st.push(ID(x)); break; case 'I': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); set_intersection(ALL(vec[s1]), ALL(vec[s2]), INS(x)); st.push(ID(x)); break; case 'A': s1 = st.top(); st.pop(); s2 = st.top(); st.pop(); x = vec[s2]; x.insert(ID(vec[s1])); st.push(ID(x)); break; default: cout&lt;&lt;"error!"; break; &#125; cout&lt;&lt;vec[st.top()].size()&lt;&lt;endl; &#125;&#125; P195 丑数HINTpriority_queue]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App场景分析与建模识别方法]]></title>
    <url>%2F2018%2F03%2F20%2FApp%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E4%B8%8E%E5%BB%BA%E6%A8%A1%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[提取出APP的UI信息，如控件的名字、坐标、尺寸、类名、内存，以及控件的树状层级关系，寻找方法通过这些UI信息得到APP当前的场景和动作，建立模型，输入为UIInfo(e.g.[[UIApp keyWindow] recursiveDescription])，输出为APPScene(e.g.发送搜索请求)。 前言提取出APP的UI信息，如控件的名字、坐标、尺寸、类名、内存，以及控件的树状层级关系，寻找方法通过这些UI信息得到APP当前的场景和动作，建立模型，输入为UIInfo(e.g.[[UIApp keyWindow] recursiveDescription])，输出为APPScene(e.g.发送搜索请求)。 想法app场景识别 App scene recognition基于文本的app场景识别 Text-based App scene recognition app行为的定义，是否能通过类名、坐标就简单定义行为。app行为和用户行为的关联。如何定义是首要的。 除了[[UIApp keyWindow] recursiveDescription]还能使用什么方法获取UIinfo 如何建模，是否用机器学习，如何将输入向量化。 场景识别(机器学习)介绍计算机视觉和场景识别的前世今生 场景识别论文阅读感想（初步） MIT Scene Recognition Demo识别图片是在室内还是室外 参考文献面向事件关系检测的特征分析与场景推理方法研究 Multi-spectral SIFT for scene category recognition Convolutional Network Features for Scene Recognition SUN database: Large-scale scene recognition from abbey to zoo Learning deep features for scene recognition using places database Scene Recognition with CNNs: Objects, Scales and Dataset Bias 机器学习和深度学习引用量最高的20篇论文（2014-2017）]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的模式匹配-BF和KMP算法]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-BF%E5%92%8CKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[母串匹配子串的常用算法，定义Tag为主串，Ptn为子串（模式串），如果在主串Tag的第pos个位置后存在与子串Ptn相同的子串，返回它在主串Tag中第pos个字符后第一次出现的位置，否则返回-1。BF算法为暴力回溯求解算法，KMP算法相对优化。 BF算法思路定义两个索引值i和j分别为Tag和Ptn的带匹配字符，匹配则自增，不匹配则i回溯为i-j+1，j回溯为0，当二者有其一索引至尾端则跳出循环，若跳出循环后j索引完了Ptn则返回i-length（Ptn），否则返回-1。 代码12345678910111213141516171819202122232425262728293031323334/*返回子串Ptn在主串Tag的第pos个字符后(含第pos个位置)第一次出现的位置，若不存在，则返回-1采用BF算法，这里的位置全部以从0开始计算为准，其中T非空，0&lt;=pos&lt;=Tlen*/int index(const string &amp;Tag,const string &amp;Ptn,int pos)&#123; int i = pos; //主串当前正待比较的位置，初始为pos int j = 0; //子串当前正待比较的位置，初始为0 int Tlen = Tag.size(); //主串长度 int Plen = Ptn.size(); //子串长度 while(i&lt;Tlen &amp;&amp; j&lt;Plen) &#123; if(Tag[i] == Ptn[j]) //如果当前字符相同，则继续向下比较 &#123; i++; j++; &#125; else //如果当前字符不同，则i和j回退，重新进行匹配 &#123; //用now_pos表示每次重新进行匹配时开始比较的位置，则 //i=now_pos+后移量，j=0+后移量 //则i-j+1=now_pos+1,即为Tag中下一轮开始比较的位置 i = i-j+1; //Ptn退回到子串开始处 j = 0; &#125; &#125; if(j &gt;= Plen) return i - Plen; else return -1;&#125; 验证123456789101112131415161718192021222324int main()&#123; char ch; do&#123; string Tag,Ptn; int pos; cout&lt;&lt;"输入主串："; cin&gt;&gt;Tag; cout&lt;&lt;"输入子串："; cin&gt;&gt;Ptn; cout&lt;&lt;"输入主串中开始进行匹配的位置（首字符位置为0）："; cin&gt;&gt;pos; int result = index(Tag,Ptn,pos); if(result != -1) cout&lt;&lt;"主串与子串在主串的第"&lt;&lt;result&lt;&lt;"个字符（首字符的位置为0）处首次匹配"&lt;&lt;endl; else cout&lt;&lt;"无匹配子串"&lt;&lt;endl; cout&lt;&lt;"是否继续测试（输入y或Y继续，任意其他键结束）："; cin&gt;&gt;ch; &#125;while(ch == 'y' || ch == 'Y'); return 0;&#125; KMP算法思路 回溯的方法不同，一旦失配，i不回溯，j回溯到一个特殊的位置，采用next[length(Ptn)]记录元素失配后回溯到的下一位置。 关键在与next数组的求解，下面举例。key：next数组是针对子串的，和母串没关。 next数组理解的举例 对于子串“ABCDABD”，对应的next数组为“-1 0 0 0 0 1 2”，下面解释next数组怎么来的。 当匹配到第六位的“B”时，如果发生了失配，j将回到1即第二位开始配，因为失配位的前一位是A，而A在子串的最开头出现过，所以j没必要回溯到0再开始匹配了。 当匹配到第七位的“D”时，如果发生了失配，j将回到2即第三位开始配，因为失配位的前两位是AB，而AB在子串的最开头出现过，所以j没必要回溯到0再开始匹配了，直接从第三位开始匹配。 所以next数组记录的是，当前位置元素往前看，比如D往前看，出现的连续字符满足和从头开始数连续字符相等的数量。比如从D往前看为AB，所以D对应2。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*返回子串Ptn在主串Tag的第pos个字符后(含第pos个位置)第一次出现的位置，若不存在，则返回-1采用KMP算法，这里的位置全部以从0开始计算为准，其中T非空，0&lt;=pos&lt;=Tlen*/int kmp_index(const string &amp;Tag,const string &amp;Ptn,int pos)&#123; int i = pos; //主串当前正待比较的位置，初始为pos int j = 0; //子串当前正待比较的位置，初始为0 int Tlen = Tag.size(); //主串长度 int Plen = Ptn.size(); //子串长度 //求next数组的值，并逐个输出 int *next = (int *)malloc(Plen*sizeof(int)); get_next(Ptn,next,Plen);// get_nextval(Ptn,next,Pln); int t; cout&lt;&lt;"子串的next数组中的各元素为："; for(t=0;t&lt;Plen;t++) cout&lt;&lt;next[t]&lt;&lt;" "; cout&lt;&lt;endl; while(i&lt;Tlen &amp;&amp; j&lt;Plen) &#123; if(j==-1 || Tag[i] == Ptn[j]) &#123; //如果当前字符相同，或者在子串的第一个字符处失配，则继续向下比较 i++; j++; &#125; else //如果当前字符不同，则i保持不变，j变为下一个开始比较的位置 &#123; //next数组时KMP算法的关键，i不回退， //而是继续与子串中的nex[j]位置的字符进行比较 j = next[j]; &#125; &#125; if(j &gt;= Plen) return i - Plen; else return -1;&#125;/*求next数组中各元素的值，保存在长为len的next数组中*/void get_next(const string &amp;Ptn,int *next,int len)&#123; int j = 0; int k = -1; next[0] = -1; while(j&lt;len-1) &#123; if(k == -1 || Ptn[j] == Ptn[k]) &#123; //如果满足上面分析的Pk = Pj的情况，则继续比较下一个字符， //并得next[j+1]=next[j]+1 j++; k++; next[j] = k; &#125; else &#123; //如果符合上面分析的第2种情况，则依据next[k]继续寻找下一个比较的位置 k = next[k]; &#125; &#125;&#125;/*求next数组的改进数组中各元素的值，保存在长为len的nextval数组中*/void get_nextval(const string &amp;Ptn,int *nextval,int len)&#123; int j = 0; int k = -1; nextval[0] = -1; while(j&lt;len-1) &#123; if(k == -1 || Ptn[j] == Ptn[k]) &#123; //如果满足上面分析的Pk = Pj的情况，则继续比较下一个字符， //并得next[j+1]=next[j]+1 j++; k++; if(Ptn[j] != Ptn[k]) nextval[j] = k; else //Ptn[j]与Ptn[k]相等时，直接跳到netval[k] nextval[j] = nextval[k]; &#125; else &#123; //如果符合上面分析的第2种情况，则依据next[k]继续寻找下一个比较的位置 k = nextval[k]; &#125; &#125;&#125; 验证123456789101112131415161718192021222324int main()&#123; char ch; do&#123; string Tag,Ptn; int pos; cout&lt;&lt;"输入主串："; cin&gt;&gt;Tag; cout&lt;&lt;"输入子串："; cin&gt;&gt;Ptn; cout&lt;&lt;"输入主串中开始进行匹配的位置（首字符位置为0）："; cin&gt;&gt;pos; int result = kmp_index(Tag,Ptn,pos); if(result != -1) cout&lt;&lt;"主串与子串在主串的第"&lt;&lt;result&lt;&lt;"个字符（首字符的位置为0）处首次匹配"&lt;&lt;endl; else cout&lt;&lt;"无匹配子串"&lt;&lt;endl; cout&lt;&lt;"是否继续测试（输入y或Y继续，任意其他键结束）："; cin&gt;&gt;ch; &#125;while(ch == 'y' || ch == 'Y'); return 0;&#125; 参考链接 【数据结构与算法】模式匹配——从BF算法到KMP算法（附完整源码） 从头到尾彻底理解KMP]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo多终端部署持续更新]]></title>
    <url>%2F2018%2F03%2F18%2Fhexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[使用hexo+git写博客十分简便高效，然而多终端的部署问题有很多坑，本博客将持续更新在多终端部署时遇到的坑。 基本方法安装git并设置关联什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash 或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后直接三个回车即可，默认不需要设置密码 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制打开GitHub_Settings_keys 页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com ： 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 检测npm是否安装成功，在命令行中输入npm -v : 到这了，安装Hexo的环境已经全部搭建完成。 github设置 在yourname.github.io仓库内创建一个新的branch，如：hexo。 将该分支设置为默认分支settings -&gt; branch -&gt; Default branch -&gt; update 在本地建立git仓库 配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public 进入blog文件夹，shift+右键打开终端 git init Initialized empty Git repository初始化git仓库 git add -A 添加本地所有文件 git commit -m &quot;blog source files&quot; 提交到本地仓库 git branch hexo 创建本地hexo分支 将本地仓库与远端关联 git remote add origin git@github.com:yourname/yourname.github.io.git 添加远程仓库 git push origin hexo -f 将本地仓库推到远端仓库(默认为hexo分支) 另一终端的所有操作 将远程clone至本地 git clone -b hexo git@github.com:yourname/yourname.github.io.git 进入clone下来的仓库以及next主题文件夹下执行安装(会根据package.json安装对应的依赖) npm install 编辑本地文件后更新远程 git add . ,git commit -m &quot;update info&quot;， git push origin hexo 部署发布博客 hexo clean hexo g -d 踩坑记暂无]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[已知中序和前序（或后序）遍历结果生成树]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%B7%B2%E7%9F%A5%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%EF%BC%88%E6%88%96%E5%90%8E%E5%BA%8F%EF%BC%89%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[如题，已知中序和前序（或后序）遍历结果生成树，算法分为两部分，一部分为已知前序和中序，另一部分为已知后序和中序。 思路已知前序和中序 定位树根，树根即当前前序的首节点。 定位树根位于中序的位置，该位置左边即左子树，右边即右子树。 递归左右子树。 已知后序和中序同理 举例 已知 后序序列 LHDKEBFGCA 中序序列 HLDBEKAFCG 求解 由后序序列定位树根，树根为A 节点A的左子树的中序为HLDBEK，左子树的后序为LHDKEB，右子树的中序为FCG，右子树的后序为FGC 对于左子树，树根为B，继续第二步，对于右子树，树根为G，继续第二步。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//// Created by Jumormt on 2018/3/17.//#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Node&#123; Node(char v='0'):value(v), left(0), right(0)&#123;&#125; char value; Node* left; Node* right;&#125;;char pre[50] = "ABDHLEKCFG"; //前序序列char mid[50] = "HLDBEKAFCG"; //中序序列char post[50] = "LHDKEBFGCA"; //后序序列class BiTree&#123;public: BiTree(Node* n):root(n)&#123;&#125; // 定位c在中序遍历的位置 int Position(char c) &#123; return strchr(mid,c)-mid; &#125;// // 数组初始化树的方法// // 注意要传入指针的引用，因为函数内试图改变指针的大小R=new Node;不加引用就是无效改变！！另外R-&gt;value = ch[i];是确实会改变传入指针所指对象的。// void Create(Node *&amp;R, int i)// &#123;// if (ch[i]==0)// R = NULL;// else// &#123;// R=new Node;// R-&gt;value = ch[i];// Create(R-&gt;left, 2*i);// Create(R-&gt;right, 2*i+1);// &#125;// &#125; // 已知前序和中序遍历整个树 注意传入新参为Node*&amp; root，因为函数内试图改变指针的大小root=new Node;不加引用就是无效改变！！另外root-&gt;value = pre[i];是确实会改变传入指针所指对象的。 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PreMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = pre[i]; int pos = Position(pre[i]); int lenL = pos - j; int lenR = length - lenL - 1; PreMidCreate(root-&gt;left, i+1, j, lenL); PreMidCreate(root-&gt;right, i+1+lenL, pos+1, lenR); &#125; // 已知后序和中序遍历整个树 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PostMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = post[i]; int pos = Position(post[i]); int lenL = pos - j; int lenR = length - lenL - 1; PostMidCreate(root-&gt;left, i-1-lenR, j, lenL); PostMidCreate(root-&gt;right, i-1, pos+1, lenR); &#125; //前序遍历 void preOrder(Node* root)&#123; if (root)&#123; cout&lt;&lt;root-&gt;value&lt;&lt;" "; preOrder(root-&gt;left); preOrder(root-&gt;right); &#125; &#125; // 中序遍历 void midOrder(Node* root)&#123; if (root)&#123; midOrder(root-&gt;left); cout&lt;&lt;root-&gt;value&lt;&lt;" "; midOrder(root-&gt;right); &#125; &#125; // 后序遍历 void postOrder(Node* root)&#123; if (root)&#123; postOrder(root-&gt;left); postOrder(root-&gt;right); cout&lt;&lt;root-&gt;value&lt;&lt;" "; &#125; &#125; void deleteTree(Node* node)&#123; if (node)&#123; deleteTree(node-&gt;left); deleteTree(node-&gt;right); delete node; &#125; &#125; ~BiTree()&#123; deleteTree(root); &#125; Node* getRoot()&#123; return root; &#125;private: Node* root;&#125;;int main()&#123; Node* node = new Node(); BiTree tree(node); tree.PreMidCreate(node, 0, 0, strlen(mid)); tree.preOrder(node);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划-大四下]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%AE%A1%E5%88%92-%E5%A4%A7%E5%9B%9B%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本科还剩下1/8，最后半年承上启下，希望对本科阶段的学习有所总结，对研究生生活有所准备，列下一个粗略的计划希望时间不会虚度。 学习毕业设计毕设需要完成一个较大的工程项目，需要掌握每个模块涉及的技术，包括爬虫、clamav和cuckoo、调度、Web。 逆向完善敏感api组合，完善cuckoo process和signature的自定义。 调度学习使用java语言，掌握基本的架构设计方案，学习thrift跨语言接口定义。 Web基本H5 + JAVA + springMVC 安全修满6学分的研究生课程，系统地学习一下信息安全技术。 智能学完之前未看完的视频，熟悉一下一些主流的框架，了解神经网络的基本应用。 算法《算法导论》+ 《算法竞赛入门经典》+ leetcode，语言使用cpp，每天定量。 未完待续健身吉他阅读kindle unlimited每周一本开始 写在最后希望能坚持写博客，记录平时的学习过程和心得感悟，在技术上和思想上都能有一定升华，望监督。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy+PhantomJS+Selenium实现动态网页的爬取]]></title>
    <url>%2F2018%2F02%2F08%2FScrapy-PhantomJS-Selenium%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[网络爬虫是数据挖掘的重要前提，通过网络爬虫可以自动化批量获取互联网上你需要的有用信息。爬虫于静态页面的爬取十分简单，但Ajax的出现实现了网页的局部动态加载，网页不需每次返回重复Html而只要局部刷新，简单的静态页面爬虫只能解析单一url而对它就无能为力了。PhantomJS+Selenium，再加上Scrapy爬虫框架，就可以实现动态爬虫。 PhantomJSPhantomJS是什么？ PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS官方地址 PhantomJS官方API PhantomJS官方示例 PhantomJS GitHub PhantomJS的使用PhantomJS的安装不再赘述，在windows平台下安装好的phantomjs.exe即可可通过JS与webkit内核交互。12345678910111213// GetHtml.jsvar page = require('webpage').create(), //获取操作dom或web网页的对象 system = require('system'), //获取操作系统对象 address;if (system.args.length === 1) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; page.open(address, function (status) &#123; //访问url console.log(page.content); phantom.exit(); &#125;);&#125; 控制台输入1phantomjs ./test.js http://baidu.com 即打印输出百度的html页面 PhantomJS参考链接 PhantomJS快速入门 phantomjs2.1 初体验 Selenium什么是Selenium？ selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。 Selenium的使用安装直接使用pip安装，详细使用详解参见参考链接，以下为简单使用介绍，即完全加载一个url（未考虑人工加载）123456// test.pyfrom selenium import webdriver driver = webdriver.PhantomJS(/path/to/PhantomJS.excuatable) # 获取浏览器对象driver.get('http://www.baidu.com/')print (driver.page_source) 参考链接 selenium用法详解 Scrapy不再赘述，直接丢出文档 PhantomJS+Selenium+Scrapy在爬虫.py中的request加入meta1request.meta[&apos;PhantomJS&apos;] = True 定义中间件1234567891011121314//JSMiddleware.pyfrom selenium import webdriverfrom scrapy.http import HtmlResponseclass PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS(executable_path='/path/to/phantomjs') driver.get(request.url) content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) settings中开启中间件1234DOWNLOADER_MIDDLEWARES = &#123; &apos;scrapy.contrib.downloadermiddlewares.useragent.UserAgentMiddleware&apos;: None, &apos;[爬虫名字].middlewares.PhantomJSMiddleware&apos;: 500,&#125; 改进-实现滚动刷新 js代码如下 12345678910111213141516171819202122// scrollToBottom.jsfunction scrollToBottom() &#123; var Height = document.body.clientHeight, //文本高度 screenHeight = window.innerHeight, //屏幕高度 INTERVAL = 100, // 滚动动作之间的间隔时间 delta = 500, //每次滚动距离 curScrollTop = 0; //当前window.scrollTop 值 var scroll = function () &#123; curScrollTop = document.body.scrollTop; window.scrollTo(0,curScrollTop + delta); &#125;; var timer = setInterval(function () &#123; var curHeight = curScrollTop + screenHeight; if (curHeight &gt;= Height)&#123; //滚动到页面底部时，结束滚动 clearInterval(timer); &#125; scroll(); &#125;, INTERVAL)&#125; 重新定义中间件 12345678910111213141516171819202122js = """// scrollToBottom.jsfunction scrollToBottom() &#123; ....&#125;scrollToBottom()"""class PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS() driver.get(request.url) driver.execute_script(js) time.sleep(1) # 等待JS执行 content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) time.sleep(&lt;wait_time&gt;)为了解决等待JS执行的时间过短会导致爬取的页面靠近底部的图片没能加载，因为滚动函数还未执行到此处。所以需要预留一个稍微长一点的等待时间。 实战参考链接 在Scrapy框架下使用Selenium+PhantomJS]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F02%2F07%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[习惯使用Markdown写博文，以下为Markdown基本语法。 标题This is an H1This is an H2这是 H1这是 H2这是 H6 特殊字符&copy; 区块引用 Blockquotes This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表 Red Green Blue Red Green Blue Red Green Blue Bird McHale Parish Bird McHale Parish Lorem ipsum dolor sit amet,consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. A list item with a blockquote: This is a blockquoteinside a list item. 代码（前面缩进）:tell application &quot;Foo&quot; beep end tell Use the printf() function. A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any haa tags. 分割线 链接Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： This is an example inline link. This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：1[id]: http://example.com/ &quot;Optional Title Here&quot;. 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址选择性地接着 title 内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： 12345 [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12 [link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调single asterisks single underscores double asterisks double underscores 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。参考式的图片语法则长得像这样： 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 z自动链接http://example.com/ &#97;&#100;&#x64;&#114;&#101;&#115;&#x73;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109; 反斜杠插入特殊字符 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向工具]]></title>
    <url>%2F2018%2F02%2F07%2FiOS%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[iOS逆向常用的一些小工具 砸壳工具dumpdecrypted的使用 将~/HackTools/dumpdecrypted-master/dumpdecrypted.dylib拷贝到TargetApp的Documents目录下 开始砸壳 1DYLD_INSERT_LIBRARIES=/path/to/dumpdecrypted.dylib /path/to/executable class-dump的使用 在Terminal中进入App所在的目录，并用Xcode自带的plutil工具查看Info.plist中的“CFBundleExecutable”字段： 1plutil -p Info.plist | grep CFBundleExecutable 将头文件dump到指定文件夹下,且内容按名字排序 1class-dump -S -s -H 可执行文件 -o 文件夹]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案]]></title>
    <url>%2F2018%2F02%2F07%2FMac%E7%B3%BB%E7%BB%9F10-11%E4%B9%8B%E5%90%8E-usr-bin-%E6%8B%B7%E8%B4%9D%E6%9D%83%E9%99%90%E7%A6%81%E6%AD%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限是禁止的，此时自定义的基础功能二进制文件使用困难，以下是比较好的解决方案，亲测有效！ Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案 Step1：在当前用户根目录下创建一个bin目录； 命令：mkdir ~/bin Step2：把要拷贝 实现基础功能的二进制 如class-dump给拷贝到这个目录里，并赋予其可执行权限; 命令一: sudo cp /.../class-dump ~/bin (/…/class-dump是指的class-dump的完整路径) 命令二: chmod +x ~/bin/class-dump Step3：打开~/.bash_profile文件，配置环境变量 命令一: vi ~/.bash_profile 命令二: 按 i 键进入编辑模式，写入下面一行代码， export PATH=$HOME/bin/:$PATH 按ESC然后输入冒号(shift+;),然后输入wq,退出即可。 Step4：在Terminal中执行source命令(每次开机后都要重新source) 命令:source ~/.bash_profile完成以上步骤，在terminal中执行class-dump实验一下，应该就可以了。 其他方案：修改系统权限 关闭 Rootless。重启按住 Command+R，进入恢复模式，打开Terminal。 csrutil disable 重启即可。如果要恢复默认，那么 csrutil enable 附录: csrutil命令参数格式： csrutil enable [--without kext | fs | debug | dtrace | nvram][--no-internal] 禁用：csrutil disable （等同于csrutil enable --without kext --without fs --without debug --without dtrace --without nvram） 其中各个开关，意义如下： B0: [kext] 允许加载不受信任的kext（与已被废除的kext-dev-mode=1等效） B1: [fs] 解锁文件系统限制 B2: [debug] 允许task_for_pid()调用 B3: [n/a] 允许内核调试 （官方的csrutil工具无法设置此位） B4: [internal] Apple内部保留位（csrutil默认会设置此位，实际不会起作用。设置与否均可） B5: [dtrace] 解锁dtrace限制 B6: [nvram] 解锁NVRAM限制 B7: [n/a] 允许设备配置（新增，具体作用暂时未确定）]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lldb+debugserver速查表]]></title>
    <url>%2F2018%2F02%2F07%2Flldb-debugserver%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[lldb+debugserver是iOS逆向的一个重要的工具，用于动态调试，包括寻找有用api、寻找有用信息等等，结合IDA构成iOS逆向的大半江山。以下是我的速查表。 一、准备阶段 iPhone端开启监听123debugserver 192.168.3.242:8888 -a &quot;SpringBoard&quot;debugserver -x backboard 192.168.3.242:8888 /Applications/AppStore.app/AppStore lldb连接iPhone1process connect connect://192.168.3.235:8888 cycript连接123ps -e | grep /Applications(位置)查看当前可执行程序cycript -p 可执行程序 二、寻找思路 列出当前镜像1image list -o -f 列出调用栈信息12345thread backtracebt [all]sbt 找到view对应的controller123456首先找到view界面的地址（easy），通过调用[#0x17f92890 nextResponder]找到controller的名字通过lldb po [controller名 _ivarDescription]和[controller名 _shortMethodDescription]看方法和属性对方法和属性所在内存下断点读取寄存器信息，获取寄存器存放的对象 下断点(通过help br查看)1234567b functionbr s -a addressbr s -a ASLR+offset...... 调试下一步1234567891011121314151617181920212223br l（断点列表）br dis 序号（不加为全）br en 序号br del 序号c(下一个断点)s 源码级别单步执行，遇到子函数则进入si 单步执行，遇到子函数则进入n 源码级别单步执行，遇到子函数不进入，直接步过ni 单步执行，遇到子函数不进入，直接步过finish/f 退出子函数br com add 序号（执行这条命令后，LLDB会要求我们设置一系列指令，以“DONE”结束，） 寄存器12345reg r -a/-A...register read -a/-A...register write 寄存器 值 （将寄存器赋值）reg w 关于打印1234567891011121314151617181920212223242526po或p $寄存器 （打印寄存器的值）po [$寄存器 或类名 _shortMethodDescription]po [$寄存器 或类名 _ivarDescription]然后通过cycript进行调用，或者lldb本身可以调用：po [$寄存器 或类名 method]po [view subviews]po [view superviews]po [$r0（寄存器、地址） detailTextLabel]po [$r2 propertyForKey:@&quot;set&quot;]拿到setter方法po [$r2 propertyForKey:@&quot;get&quot;]拿到getter方法po[$r2 allTargets]拿到调用者，用于写在函数前面拿到了调用者也相当于拿到了类，可以用method或class-dump定位方法和属性，用ida定位方法，进入方法内部作进一步分析，结合lldb再做断点调试，看寄存器的method，看target和寄存器存放的形参。po [button allControlEvents]拿到部分形参[button actionsForTarget:#0x14609d00forControlEvent:64] 通过help ..查看详细 “函数的前4个参数存放在R0到R3中，其他参数存放在栈中；返回值放在R0中。” 12&gt; debugserver -x backboard 192.168.3.183:8888 /var/containers/Bundle/Application/A910BD37-4684-49A6-97A7-924891F98D90/WYParking.app/WYParking&gt;]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cuckoo沙箱问题列表]]></title>
    <url>%2F2018%2F01%2F10%2Fcuckoo%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言cuckoo sandbox是近年来一款非常好的动态检测开源工具，然而最新版本不支持py3，对中文不友好等问题凸显，以下是使用cuckoo沙箱遇到的问题汇总 解决中文适配问题 如下文件需指定编码 : #coding:utf-8 .cuckoo-&gt;analyzer-&gt;windows-&gt;analyzer.py .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;[all] .cuckoo-&gt;analyzer-&gt;windows-&gt;modules-&gt;packages-&gt;[all] 其他涉及打印、日志、执行包含中文路径文件 如下文件修改： .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py中 path = path.decode(&#39;utf-8&#39;) .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;human.py中指定需要识别中文 其他涉及打印、日志、执行包含中文路径文件中中文字符串 sudo cuckoo submit --package sp -o path=&quot;C://Program Files//Notepad加加//notepad++.exe&quot; test.bat其他 mongodb在重启后，需要重新建立启动文件夹 sudo rm -rf /data sudo mkdir -p /data/db sudo mongod (另一终端)sudo mongo]]></content>
      <categories>
        <category>PC应用检测</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Python</tag>
        <tag>cuckoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳辅助(转)]]></title>
    <url>%2F2018%2F01%2F10%2F%EF%BC%88%E8%BD%AC%EF%BC%89%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[教你用 Python 来玩微信跳一跳游戏模式2017 年 12 月 28 日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 DEMO「跳一跳」。这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。分数越高，那么在好友排行榜更加靠前。通过 Python 脚本自动运行，让你轻松霸榜。 可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。如果能利用图像识别精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃。 原理说明 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 12adb shell screencap -p /sdcard/autojump.pngadb pull /sdcard/autojump.png . 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳 1adb shell input swipe x y x y time(ms) 使用教程 方法 1：使用 app 进行一键操作。目前已适配 Win10 64位/macOS 平台 Android 一键操作，下载请移步 STOP_jump 方法 2：相关软件工具安装和使用步骤请参考 Android 和 iOS 操作步骤 FAQ 详见 Wiki-FAQ 更新日志 详见 changelog 开发者列表 详见 contributors QQ 交流 314659953 (1000人 已满) 176740763 (500人 已满) 89213434 (2000人 已满) 64389940 (2000人)]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Games</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CppPrimer5_ch01_answers]]></title>
    <url>%2F2018%2F01%2F08%2FCppPrimer5-ch01-answers%2F</url>
    <content type="text"><![CDATA[前言《CppPrimer5》第一章课后答案 Exercise 1.1 Review the documentation for your compiler and determine what file naming convention it uses. Compile and run the main program from page 2. Windows Linux Exercise 1.2 Exercise 1.2: Change the program to return -1. A return value of -1 is often treated as an indicator that the program failed. Recompile and rerun your program to see how your system treats a failure indicator from main. Windows Linux 255? why? please look at this Exercise 1.3 Write a program to print Hello, World on the standard output. 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello, World" &lt;&lt; std::endl; return 0;&#125; Exercise 1.4 Our program used the addition operator, +, to add two numbers. Write a program that uses the multiplication operator, *, to print the product instead. 1234567891011#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 * v2 &lt;&lt; std::endl; return 0;&#125; Exercise 1.5 We wrote the output in one large statement. Rewrite the program to use a separate statement to print each operand. 12345678910111213141516#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of "; std::cout &lt;&lt; v1; std::cout &lt;&lt; " and "; std::cout &lt;&lt; v2; std::cout &lt;&lt; " is "; std::cout &lt;&lt; v1 * v2; std::cout &lt;&lt; std::endl; return 0;&#125; Exercise 1.6 Explain whether the following program fragment is legal. It’s illegal. [Error] expected primary-expression before ‘&lt;&lt;’ token Fixed it: remove the spare semicolons. 123std::cout &lt;&lt; "The sum of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 + v2 &lt;&lt; std::endl; Exercise 1.7 Compile a program that has incorrectly nested comments. Example:123456789/** comment pairs /* */ cannot nest.* ''cannot nest'' is considered source code,* as is the rest of the program*/int main()&#123; return 0;&#125; Compiled result(g++): Exercise 1.8 Indicate which, if any, of the following output statements are legal:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */;std::cout &lt;&lt; /* "*/" /* "/*" */; After you’ve predicted what will happen, test your answers by compiling aprogram with each of these statements. Correct any errors you encounter. Compiled result(g++): Corrected? just added a quote:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */";std::cout &lt;&lt; /* "*/" /* "/*" */; Output: /**/ */ /* Exercise 1.9Exercise 1.10Exercise 1.11Exercise 1.12 What does the following for loop do? What is the final valueof sum?123int sum = 0;for (int i = -100; i &lt;= 100; ++i)sum += i; the loop sums the numbers from -100 to 100. the final value of sum is zero. Exercise 1.13 Rewrite the exercises from § 1.4.1 (p. 13) using for loops. Ex1.9:123456789101112#include &lt;iostream&gt;int main()&#123; int sum = 0; for (int i=50; i&lt;=100; ++i) sum += i; std::cout &lt;&lt; "the sum is: " &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; Ex1.10:123456789#include &lt;iostream&gt;int main()&#123; for (int i=10; i&gt;=0; --i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Ex1.11:1234567891011121314151617181920#include &lt;iostream&gt;int main()&#123; int val_small = 0, val_big = 0; std::cout &lt;&lt; "please input two integers:"; std::cin &gt;&gt; val_small &gt;&gt; val_big; if (val_small &gt; val_big) &#123; int tmp = val_small; val_small = val_big; val_big = tmp; &#125; for (int i=val_small; i&lt;=val_big; ++i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Exercise 1.14 Compare and contrast the loops that used a for with thoseusing a while. Are there advantages or disadvantages to using either form? If you need a pattern which is using a variable in a condition and incrementing that variable in thebody. You should use for loop. Else the while loop is more simple. Want to know more? look at this Exercise 1.15 Write programs that contain the common errors discussed inthe box on page 16. Familiarize yourself with the messages the compilergenerates. JUST READ IT! Exercise 1.16 Write your own version of a program that prints the sum of a set of integers read from cin. Many people confused about this exercise, such as this and this. In my opinion, the exercise aim to write the program without “END-OF-FILE“. BUT, the code in first link is not correct. The following are my own version: 12345678910111213141516#include &lt;iostream&gt;int main()&#123; int limit = 0, sum = 0, value = 0; std::cout &lt;&lt; "How many integers would you like to enter?"; std::cin &gt;&gt; limit; // assume we don't know what is EOF(End-Of-File). while (std::cin &gt;&gt; value &amp;&amp; (--limit != 0)) sum += value; std::cout &lt;&lt; sum + value &lt;&lt; std::endl; return 0;&#125; Watch out for “sum + value” in the cout line. Exercise 1.17 What happens in the program presented in this section if the input values are all equal? What if there are no duplicated values? If the input values are all equal, it will print a line which shows the count of the number you input. If there are no duplicated values, when different values input, a new line will be printed if you click Enter. Exercise 1.18 Compile and run the program from this section giving it only equal values as input. Run it again giving it values in which no number is repeated. Exercise 1.19 Revise the program you wrote for the exercises in § 1.4.1 (p. 13) that printed a range of numbers so that it handles input in which the first number is smaller than the second. Yes, we should use if to judge which is bigger. review this code Exercise 1.20 http://www.informit.com/title/032174113 contains a copy of Sales_item.h in the Chapter 1 code directory. Copy that file to your working directory. Use it to write a program that reads a set of book sales transactions, writing each transaction to the standard output. Here is the code. You need to enable C++11 support in your compiler.With GCC and Clang, this can be done with the -std=c++11 option. (Never say it again.) How to test it? use the book.txt in data folder. And do it like this: Exercise 1.21 Write a program that reads two Sales_item objects that have the same ISBN and produces their sum. The program should check whether the objects have the same ISBN.(Have a look at 1.5.2, surprise!) Code Exercise 1.22 Write a program that reads several transactions for the same ISBN. Write the sum of all the transactions that were read. Tips: this program will appear in the section 1.6. Here is the code. Exercise 1.23 Write a program that reads several transactions and countshow many transactions occur for each ISBN. Tip: please review the 1.4.4. Here is the code. Exercise 1.24 Test the previous program by giving multiple transactionsrepresenting multiple ISBNs. The records for each ISBN should be groupedtogether. You can use data/book.txt as the records. Exercise 1.25 Using the Sales_item.h header from the Web site,compile and execute the bookstore program presented in this section. It is the same as Exercise 1.22.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blah blah blah Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Guide</tag>
      </tags>
  </entry>
</search>
