<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[已知中序和前序（或后序）遍历结果生成树]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%B7%B2%E7%9F%A5%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%EF%BC%88%E6%88%96%E5%90%8E%E5%BA%8F%EF%BC%89%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[如题，已知中序和前序（或后序）遍历结果生成树，算法分为两部分，一部分为已知前序和中序，另一部分为已知后序和中序。 思路已知前序和中序 定位树根，树根即当前前序的首节点。 定位树根位于中序的位置，该位置左边即左子树，右边即右子树。 递归左右子树。 已知后序和中序同理 举例 已知 后序序列 LHDKEBFGCA 中序序列 HLDBEKAFCG 求解 由后序序列定位树根，树根为A 节点A的左子树的中序为HLDBEK，左子树的后序为LHDKEB，右子树的中序为FCG，右子树的后序为FGC 对于左子树，树根为B，继续第二步，对于右子树，树根为G，继续第二步。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//// Created by Jumormt on 2018/3/17.//#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Node&#123; Node(char v='0'):value(v), left(0), right(0)&#123;&#125; char value; Node* left; Node* right;&#125;;char pre[50] = "ABDHLEKCFG"; //前序序列char mid[50] = "HLDBEKAFCG"; //中序序列char post[50] = "LHDKEBFGCA"; //后序序列class BiTree&#123;public: BiTree(Node* n):root(n)&#123;&#125; // 定位c在中序遍历的位置 int Position(char c) &#123; return strchr(mid,c)-mid; &#125;// // 数组初始化树的方法// // 注意要传入指针的引用，因为函数内试图改变指针的大小R=new Node;不加引用就是无效改变！！另外R-&gt;value = ch[i];是确实会改变传入指针所指对象的。// void Create(Node *&amp;R, int i)// &#123;// if (ch[i]==0)// R = NULL;// else// &#123;// R=new Node;// R-&gt;value = ch[i];// Create(R-&gt;left, 2*i);// Create(R-&gt;right, 2*i+1);// &#125;// &#125; // 已知前序和中序遍历整个树 注意传入新参为Node*&amp; root，因为函数内试图改变指针的大小root=new Node;不加引用就是无效改变！！另外root-&gt;value = pre[i];是确实会改变传入指针所指对象的。 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PreMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = pre[i]; int pos = Position(pre[i]); int lenL = pos - j; int lenR = length - lenL - 1; PreMidCreate(root-&gt;left, i+1, j, lenL); PreMidCreate(root-&gt;right, i+1+lenL, pos+1, lenR); &#125; // 已知后序和中序遍历整个树 // root为当前遍历树的根节点，i为当前根节点在__前序__遍历pre的序号，j为在__中序__遍历中树序列mid始序号。 void PostMidCreate(Node*&amp; root, int i, int j, int length)&#123; if (length &lt;= 0) return; root = new Node(); root-&gt;value = post[i]; int pos = Position(post[i]); int lenL = pos - j; int lenR = length - lenL - 1; PostMidCreate(root-&gt;left, i-1-lenR, j, lenL); PostMidCreate(root-&gt;right, i-1, pos+1, lenR); &#125; //前序遍历 void preOrder(Node* root)&#123; if (root)&#123; cout&lt;&lt;root-&gt;value&lt;&lt;" "; preOrder(root-&gt;left); preOrder(root-&gt;right); &#125; &#125; // 中序遍历 void midOrder(Node* root)&#123; if (root)&#123; midOrder(root-&gt;left); cout&lt;&lt;root-&gt;value&lt;&lt;" "; midOrder(root-&gt;right); &#125; &#125; // 后序遍历 void postOrder(Node* root)&#123; if (root)&#123; postOrder(root-&gt;left); postOrder(root-&gt;right); cout&lt;&lt;root-&gt;value&lt;&lt;" "; &#125; &#125; void deleteTree(Node* node)&#123; if (node)&#123; deleteTree(node-&gt;left); deleteTree(node-&gt;right); delete node; &#125; &#125; ~BiTree()&#123; deleteTree(root); &#125; Node* getRoot()&#123; return root; &#125;private: Node* root;&#125;;int main()&#123; Node* node = new Node(); BiTree tree(node); tree.PreMidCreate(node, 0, 0, strlen(mid)); tree.preOrder(node);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划-大四下]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%AE%A1%E5%88%92-%E5%A4%A7%E5%9B%9B%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本科还剩下1/8，最后半年承上启下，希望对本科阶段的学习有所总结，对研究生生活有所准备，列下一个粗略的计划希望时间不会虚度。 学习毕业设计毕设需要完成一个较大的工程项目，需要掌握每个模块涉及的技术，包括爬虫、clamav和cuckoo、调度、Web。 逆向完善敏感api组合，完善cuckoo process和signature的自定义。 调度学习使用java语言，掌握基本的架构设计方案，学习thrift跨语言接口定义。 Web基本H5 + JAVA + springMVC 安全修满6学分的研究生课程，系统地学习一下网络攻防。 智能学完之前未看完的视频，熟悉一下一些主流的框架，了解神经网络的基本应用。 算法《算法导论》+ leetcode，语言使用cpp，每天定量。 未完待续健身吉他阅读kindle unlimited每周一本开始 写在最后希望能坚持写博客，记录平时的学习过程和心得感悟，在技术上和思想上都能有一定升华，望监督。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy+PhantomJS+Selenium实现动态网页的爬取]]></title>
    <url>%2F2018%2F02%2F08%2FScrapy-PhantomJS-Selenium%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[网络爬虫是数据挖掘的重要前提，通过网络爬虫可以自动化批量获取互联网上你需要的有用信息。爬虫于静态页面的爬取十分简单，但Ajax的出现实现了网页的局部动态加载，网页不需每次返回重复Html而只要局部刷新，简单的静态页面爬虫只能解析单一url而对它就无能为力了。PhantomJS+Selenium，再加上Scrapy爬虫框架，就可以实现动态爬虫。 PhantomJSPhantomJS是什么？ PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS官方地址 PhantomJS官方API PhantomJS官方示例 PhantomJS GitHub PhantomJS的使用PhantomJS的安装不再赘述，在windows平台下安装好的phantomjs.exe即可可通过JS与webkit内核交互。12345678910111213// GetHtml.jsvar page = require('webpage').create(), //获取操作dom或web网页的对象 system = require('system'), //获取操作系统对象 address;if (system.args.length === 1) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; page.open(address, function (status) &#123; //访问url console.log(page.content); phantom.exit(); &#125;);&#125; 控制台输入1phantomjs ./test.js http://baidu.com 即打印输出百度的html页面 PhantomJS参考链接 PhantomJS快速入门 phantomjs2.1 初体验 Selenium什么是Selenium？ selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。 Selenium的使用安装直接使用pip安装，详细使用详解参见参考链接，以下为简单使用介绍，即完全加载一个url（未考虑人工加载）123456// test.pyfrom selenium import webdriver driver = webdriver.PhantomJS(/path/to/PhantomJS.excuatable) # 获取浏览器对象driver.get('http://www.baidu.com/')print (driver.page_source) 参考链接 selenium用法详解 Scrapy不再赘述，直接丢出文档 PhantomJS+Selenium+Scrapy在爬虫.py中的request加入meta1request.meta[&apos;PhantomJS&apos;] = True 定义中间件1234567891011121314//JSMiddleware.pyfrom selenium import webdriverfrom scrapy.http import HtmlResponseclass PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS(executable_path='/path/to/phantomjs') driver.get(request.url) content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) settings中开启中间件1234DOWNLOADER_MIDDLEWARES = &#123; &apos;scrapy.contrib.downloadermiddlewares.useragent.UserAgentMiddleware&apos;: None, &apos;[爬虫名字].middlewares.PhantomJSMiddleware&apos;: 500,&#125; 改进-实现滚动刷新 js代码如下 12345678910111213141516171819202122// scrollToBottom.jsfunction scrollToBottom() &#123; var Height = document.body.clientHeight, //文本高度 screenHeight = window.innerHeight, //屏幕高度 INTERVAL = 100, // 滚动动作之间的间隔时间 delta = 500, //每次滚动距离 curScrollTop = 0; //当前window.scrollTop 值 var scroll = function () &#123; curScrollTop = document.body.scrollTop; window.scrollTo(0,curScrollTop + delta); &#125;; var timer = setInterval(function () &#123; var curHeight = curScrollTop + screenHeight; if (curHeight &gt;= Height)&#123; //滚动到页面底部时，结束滚动 clearInterval(timer); &#125; scroll(); &#125;, INTERVAL)&#125; 重新定义中间件 12345678910111213141516171819202122js = """// scrollToBottom.jsfunction scrollToBottom() &#123; ....&#125;scrollToBottom()"""class PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS() driver.get(request.url) driver.execute_script(js) time.sleep(1) # 等待JS执行 content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) time.sleep(&lt;wait_time&gt;)为了解决等待JS执行的时间过短会导致爬取的页面靠近底部的图片没能加载，因为滚动函数还未执行到此处。所以需要预留一个稍微长一点的等待时间。 实战参考链接 在Scrapy框架下使用Selenium+PhantomJS]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F02%2F07%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[习惯使用Markdown写博文，以下为Markdown基本语法。 标题This is an H1This is an H2这是 H1这是 H2这是 H6 特殊字符&copy; 区块引用 Blockquotes This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表 Red Green Blue Red Green Blue Red Green Blue Bird McHale Parish Bird McHale Parish Lorem ipsum dolor sit amet,consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. A list item with a blockquote: This is a blockquoteinside a list item. 代码（前面缩进）:tell application &quot;Foo&quot; beep end tell Use the printf() function. A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any haa tags. 分割线 链接Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： This is an example inline link. This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：1[id]: http://example.com/ &quot;Optional Title Here&quot;. 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址选择性地接着 title 内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： 12345 [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12 [link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调single asterisks single underscores double asterisks double underscores 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。参考式的图片语法则长得像这样： 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 z自动链接http://example.com/ &#97;&#100;&#100;&#x72;&#101;&#115;&#115;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d; 反斜杠插入特殊字符 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向工具]]></title>
    <url>%2F2018%2F02%2F07%2FiOS%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[iOS逆向常用的一些小工具 砸壳工具dumpdecrypted的使用 将~/HackTools/dumpdecrypted-master/dumpdecrypted.dylib拷贝到TargetApp的Documents目录下 开始砸壳 1DYLD_INSERT_LIBRARIES=/path/to/dumpdecrypted.dylib /path/to/executable class-dump的使用 在Terminal中进入App所在的目录，并用Xcode自带的plutil工具查看Info.plist中的“CFBundleExecutable”字段： 1plutil -p Info.plist | grep CFBundleExecutable 将头文件dump到指定文件夹下,且内容按名字排序 1class-dump -S -s -H 可执行文件 -o 文件夹]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案]]></title>
    <url>%2F2018%2F02%2F07%2FMac%E7%B3%BB%E7%BB%9F10-11%E4%B9%8B%E5%90%8E-usr-bin-%E6%8B%B7%E8%B4%9D%E6%9D%83%E9%99%90%E7%A6%81%E6%AD%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Mac系统10.11之后/usr/bin 拷贝权限是禁止的，此时自定义的基础功能二进制文件使用困难，以下是比较好的解决方案，亲测有效！ Mac系统10.11之后/usr/bin 拷贝权限禁止解决方案 Step1：在当前用户根目录下创建一个bin目录； 命令：mkdir ~/bin Step2：把要拷贝 实现基础功能的二进制 如class-dump给拷贝到这个目录里，并赋予其可执行权限; 命令一: sudo cp /.../class-dump ~/bin (/…/class-dump是指的class-dump的完整路径) 命令二: chmod +x ~/bin/class-dump Step3：打开~/.bash_profile文件，配置环境变量 命令一: vi ~/.bash_profile 命令二: 按 i 键进入编辑模式，写入下面一行代码， export PATH=$HOME/bin/:$PATH 按ESC然后输入冒号(shift+;),然后输入wq,退出即可。 Step4：在Terminal中执行source命令(每次开机后都要重新source) 命令:source ~/.bash_profile完成以上步骤，在terminal中执行class-dump实验一下，应该就可以了。 其他方案：修改系统权限 关闭 Rootless。重启按住 Command+R，进入恢复模式，打开Terminal。 csrutil disable 重启即可。如果要恢复默认，那么 csrutil enable 附录: csrutil命令参数格式： csrutil enable [--without kext | fs | debug | dtrace | nvram][--no-internal] 禁用：csrutil disable （等同于csrutil enable --without kext --without fs --without debug --without dtrace --without nvram） 其中各个开关，意义如下： B0: [kext] 允许加载不受信任的kext（与已被废除的kext-dev-mode=1等效） B1: [fs] 解锁文件系统限制 B2: [debug] 允许task_for_pid()调用 B3: [n/a] 允许内核调试 （官方的csrutil工具无法设置此位） B4: [internal] Apple内部保留位（csrutil默认会设置此位，实际不会起作用。设置与否均可） B5: [dtrace] 解锁dtrace限制 B6: [nvram] 解锁NVRAM限制 B7: [n/a] 允许设备配置（新增，具体作用暂时未确定）]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lldb+debugserver速查表]]></title>
    <url>%2F2018%2F02%2F07%2Flldb-debugserver%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[lldb+debugserver是iOS逆向的一个重要的工具，用于动态调试，包括寻找有用api、寻找有用信息等等，结合IDA构成iOS逆向的大半江山。以下是我的速查表。 一、准备阶段 iPhone端开启监听123debugserver 192.168.3.242:8888 -a &quot;SpringBoard&quot;debugserver -x backboard 192.168.3.242:8888 /Applications/AppStore.app/AppStore lldb连接iPhone1process connect connect://192.168.3.235:8888 cycript连接123ps -e | grep /Applications(位置)查看当前可执行程序cycript -p 可执行程序 二、寻找思路 列出当前镜像1image list -o -f 列出调用栈信息12345thread backtracebt [all]sbt 找到view对应的controller123456首先找到view界面的地址（easy），通过调用[#0x17f92890 nextResponder]找到controller的名字通过lldb po [controller名 _ivarDescription]和[controller名 _shortMethodDescription]看方法和属性对方法和属性所在内存下断点读取寄存器信息，获取寄存器存放的对象 下断点(通过help br查看)1234567b functionbr s -a addressbr s -a ASLR+offset...... 调试下一步1234567891011121314151617181920212223br l（断点列表）br dis 序号（不加为全）br en 序号br del 序号c(下一个断点)s 源码级别单步执行，遇到子函数则进入si 单步执行，遇到子函数则进入n 源码级别单步执行，遇到子函数不进入，直接步过ni 单步执行，遇到子函数不进入，直接步过finish/f 退出子函数br com add 序号（执行这条命令后，LLDB会要求我们设置一系列指令，以“DONE”结束，） 寄存器12345reg r -a/-A...register read -a/-A...register write 寄存器 值 （将寄存器赋值）reg w 关于打印1234567891011121314151617181920212223242526po或p $寄存器 （打印寄存器的值）po [$寄存器 或类名 _shortMethodDescription]po [$寄存器 或类名 _ivarDescription]然后通过cycript进行调用，或者lldb本身可以调用：po [$寄存器 或类名 method]po [view subviews]po [view superviews]po [$r0（寄存器、地址） detailTextLabel]po [$r2 propertyForKey:@&quot;set&quot;]拿到setter方法po [$r2 propertyForKey:@&quot;get&quot;]拿到getter方法po[$r2 allTargets]拿到调用者，用于写在函数前面拿到了调用者也相当于拿到了类，可以用method或class-dump定位方法和属性，用ida定位方法，进入方法内部作进一步分析，结合lldb再做断点调试，看寄存器的method，看target和寄存器存放的形参。po [button allControlEvents]拿到部分形参[button actionsForTarget:#0x14609d00forControlEvent:64] 通过help ..查看详细 “函数的前4个参数存放在R0到R3中，其他参数存放在栈中；返回值放在R0中。” 12&gt; debugserver -x backboard 192.168.3.183:8888 /var/containers/Bundle/Application/A910BD37-4684-49A6-97A7-924891F98D90/WYParking.app/WYParking&gt;]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>tool</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cuckoo沙箱问题列表]]></title>
    <url>%2F2018%2F01%2F10%2Fcuckoo%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言cuckoo sandbox是近年来一款非常好的动态检测开源工具，然而最新版本不支持py3，对中文不友好等问题凸显，以下是使用cuckoo沙箱遇到的问题汇总 解决中文适配问题 如下文件需指定编码 : #coding:utf-8 .cuckoo-&gt;analyzer-&gt;windows-&gt;analyzer.py .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;[all] .cuckoo-&gt;analyzer-&gt;windows-&gt;modules-&gt;packages-&gt;[all] 其他涉及打印、日志、执行包含中文路径文件 如下文件修改： .cuckoo-&gt;analyzer-&gt;windows-&gt;lib-&gt;common-&gt;abstracts.py中 path = path.decode(&#39;utf-8&#39;) .cuckoo-&gt;analyzer-&gt;windows-&gt;mudules-&gt;auxilary-&gt;human.py中指定需要识别中文 其他涉及打印、日志、执行包含中文路径文件中中文字符串 sudo cuckoo submit --package sp -o path=&quot;C://Program Files//Notepad加加//notepad++.exe&quot; test.bat其他 mongodb在重启后，需要重新建立启动文件夹 sudo rm -rf /data sudo mkdir -p /data/db sudo mongod (另一终端)sudo mongo]]></content>
      <categories>
        <category>PC应用检测</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>cuckoo</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳辅助(转)]]></title>
    <url>%2F2018%2F01%2F10%2F%EF%BC%88%E8%BD%AC%EF%BC%89%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[教你用 Python 来玩微信跳一跳游戏模式2017 年 12 月 28 日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 DEMO「跳一跳」。这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。分数越高，那么在好友排行榜更加靠前。通过 Python 脚本自动运行，让你轻松霸榜。 可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。如果能利用图像识别精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃。 原理说明 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 12adb shell screencap -p /sdcard/autojump.pngadb pull /sdcard/autojump.png . 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳 1adb shell input swipe x y x y time(ms) 使用教程 方法 1：使用 app 进行一键操作。目前已适配 Win10 64位/macOS 平台 Android 一键操作，下载请移步 STOP_jump 方法 2：相关软件工具安装和使用步骤请参考 Android 和 iOS 操作步骤 FAQ 详见 Wiki-FAQ 更新日志 详见 changelog 开发者列表 详见 contributors QQ 交流 314659953 (1000人 已满) 176740763 (500人 已满) 89213434 (2000人 已满) 64389940 (2000人)]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Games</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CppPrimer5_ch01_answers]]></title>
    <url>%2F2018%2F01%2F08%2FCppPrimer5-ch01-answers%2F</url>
    <content type="text"><![CDATA[前言《CppPrimer5》第一章课后答案 Exercise 1.1 Review the documentation for your compiler and determine what file naming convention it uses. Compile and run the main program from page 2. Windows Linux Exercise 1.2 Exercise 1.2: Change the program to return -1. A return value of -1 is often treated as an indicator that the program failed. Recompile and rerun your program to see how your system treats a failure indicator from main. Windows Linux 255? why? please look at this Exercise 1.3 Write a program to print Hello, World on the standard output. 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello, World" &lt;&lt; std::endl; return 0;&#125; Exercise 1.4 Our program used the addition operator, +, to add two numbers. Write a program that uses the multiplication operator, *, to print the product instead. 1234567891011#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 * v2 &lt;&lt; std::endl; return 0;&#125; Exercise 1.5 We wrote the output in one large statement. Rewrite the program to use a separate statement to print each operand. 12345678910111213141516#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Enter two numbers:" &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; "The product of "; std::cout &lt;&lt; v1; std::cout &lt;&lt; " and "; std::cout &lt;&lt; v2; std::cout &lt;&lt; " is "; std::cout &lt;&lt; v1 * v2; std::cout &lt;&lt; std::endl; return 0;&#125; Exercise 1.6 Explain whether the following program fragment is legal. It’s illegal. [Error] expected primary-expression before ‘&lt;&lt;’ token Fixed it: remove the spare semicolons. 123std::cout &lt;&lt; "The sum of " &lt;&lt; v1 &lt;&lt; " and " &lt;&lt; v2 &lt;&lt; " is " &lt;&lt; v1 + v2 &lt;&lt; std::endl; Exercise 1.7 Compile a program that has incorrectly nested comments. Example:123456789/** comment pairs /* */ cannot nest.* ''cannot nest'' is considered source code,* as is the rest of the program*/int main()&#123; return 0;&#125; Compiled result(g++): Exercise 1.8 Indicate which, if any, of the following output statements are legal:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */;std::cout &lt;&lt; /* "*/" /* "/*" */; After you’ve predicted what will happen, test your answers by compiling aprogram with each of these statements. Correct any errors you encounter. Compiled result(g++): Corrected? just added a quote:1234std::cout &lt;&lt; "/*";std::cout &lt;&lt; "*/";std::cout &lt;&lt; /* "*/" */";std::cout &lt;&lt; /* "*/" /* "/*" */; Output: /**/ */ /* Exercise 1.9Exercise 1.10Exercise 1.11Exercise 1.12 What does the following for loop do? What is the final valueof sum?123int sum = 0;for (int i = -100; i &lt;= 100; ++i)sum += i; the loop sums the numbers from -100 to 100. the final value of sum is zero. Exercise 1.13 Rewrite the exercises from § 1.4.1 (p. 13) using for loops. Ex1.9:123456789101112#include &lt;iostream&gt;int main()&#123; int sum = 0; for (int i=50; i&lt;=100; ++i) sum += i; std::cout &lt;&lt; "the sum is: " &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; Ex1.10:123456789#include &lt;iostream&gt;int main()&#123; for (int i=10; i&gt;=0; --i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Ex1.11:1234567891011121314151617181920#include &lt;iostream&gt;int main()&#123; int val_small = 0, val_big = 0; std::cout &lt;&lt; "please input two integers:"; std::cin &gt;&gt; val_small &gt;&gt; val_big; if (val_small &gt; val_big) &#123; int tmp = val_small; val_small = val_big; val_big = tmp; &#125; for (int i=val_small; i&lt;=val_big; ++i) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Exercise 1.14 Compare and contrast the loops that used a for with thoseusing a while. Are there advantages or disadvantages to using either form? If you need a pattern which is using a variable in a condition and incrementing that variable in thebody. You should use for loop. Else the while loop is more simple. Want to know more? look at this Exercise 1.15 Write programs that contain the common errors discussed inthe box on page 16. Familiarize yourself with the messages the compilergenerates. JUST READ IT! Exercise 1.16 Write your own version of a program that prints the sum of a set of integers read from cin. Many people confused about this exercise, such as this and this. In my opinion, the exercise aim to write the program without “END-OF-FILE“. BUT, the code in first link is not correct. The following are my own version: 12345678910111213141516#include &lt;iostream&gt;int main()&#123; int limit = 0, sum = 0, value = 0; std::cout &lt;&lt; "How many integers would you like to enter?"; std::cin &gt;&gt; limit; // assume we don't know what is EOF(End-Of-File). while (std::cin &gt;&gt; value &amp;&amp; (--limit != 0)) sum += value; std::cout &lt;&lt; sum + value &lt;&lt; std::endl; return 0;&#125; Watch out for “sum + value” in the cout line. Exercise 1.17 What happens in the program presented in this section if the input values are all equal? What if there are no duplicated values? If the input values are all equal, it will print a line which shows the count of the number you input. If there are no duplicated values, when different values input, a new line will be printed if you click Enter. Exercise 1.18 Compile and run the program from this section giving it only equal values as input. Run it again giving it values in which no number is repeated. Exercise 1.19 Revise the program you wrote for the exercises in § 1.4.1 (p. 13) that printed a range of numbers so that it handles input in which the first number is smaller than the second. Yes, we should use if to judge which is bigger. review this code Exercise 1.20 http://www.informit.com/title/032174113 contains a copy of Sales_item.h in the Chapter 1 code directory. Copy that file to your working directory. Use it to write a program that reads a set of book sales transactions, writing each transaction to the standard output. Here is the code. You need to enable C++11 support in your compiler.With GCC and Clang, this can be done with the -std=c++11 option. (Never say it again.) How to test it? use the book.txt in data folder. And do it like this: Exercise 1.21 Write a program that reads two Sales_item objects that have the same ISBN and produces their sum. The program should check whether the objects have the same ISBN.(Have a look at 1.5.2, surprise!) Code Exercise 1.22 Write a program that reads several transactions for the same ISBN. Write the sum of all the transactions that were read. Tips: this program will appear in the section 1.6. Here is the code. Exercise 1.23 Write a program that reads several transactions and countshow many transactions occur for each ISBN. Tip: please review the 1.4.4. Here is the code. Exercise 1.24 Test the previous program by giving multiple transactionsrepresenting multiple ISBNs. The records for each ISBN should be groupedtogether. You can use data/book.txt as the records. Exercise 1.25 Using the Sales_item.h header from the Web site,compile and execute the bookstore program presented in this section. It is the same as Exercise 1.22.]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blah blah blah Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Guide</tag>
      </tags>
  </entry>
</search>
